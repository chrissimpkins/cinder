{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Inicio Sobre \u00b6 Cinder es un tema limpio y con capacidad de respuesta para sitios de documentaci\u00f3n est\u00e1tica que se generan con MkDocs . Est\u00e1 construido sobre Bootstrap 3 framework . Blog \u00b6 Arquitectura WordPress PrestaShop en Docker","title":"Home"},{"location":"#sobre","text":"Cinder es un tema limpio y con capacidad de respuesta para sitios de documentaci\u00f3n est\u00e1tica que se generan con MkDocs . Est\u00e1 construido sobre Bootstrap 3 framework .","title":"Sobre"},{"location":"#blog","text":"Arquitectura WordPress PrestaShop en Docker","title":"Blog"},{"location":"arquitectura-wordpress/","text":"Pr\u00e1ctica 9 de IAW - Instalaci\u00f3n de WordPress en distintos niveles \u00b6 Esta pr\u00e1ctica la realizaremos por fases, en la primera fase, fase-0, realizaremos la instalaci\u00f3n de WordPress en un \u00fanico nodo o instancia, en la segunda fase, fase-1, realizaremos la misma instalaci\u00f3n en dos niveles, un frontend (servidor web Apache2) y un backend (servidor SQL), por \u00faltimo, en la tercera fase, fase-2, realizaremos la instalaci\u00f3n de un balanceador de carga, dos frontend, un backend y un servidor NFS para almacenar datos compartidos para los dos frontend. Los requisitos para las tres fases con una instancia Ubuntu Server 22.04 o Ubuntu Server 20.04 con al menos 2GB de RAM . Tendremos en cuenta los puertos de entrada en cada m\u00e1quina que tendremos que abrir: Nodo \u00fanico --> HTTPS (puerto 443), HTTP (puerto 80) y SSH (puerto 22) Frontend sin balanceador de carga --> HTTPS (puerto 443), HTTP (puerto 80) y SSH (puerto 22) Frontend con balanceador de carga --> HTTP (puerto 80) y SSH (puerto 22) Backend --> MySQL/Aurora (puerto 3306) y SSH (puerto 22) Balanceador de carga --> HTTPS (puerto 443), HTTP (puerto 80) y SSH (puerto 22) NFS Server --> NFS (puerto 2049) y SSH (puerto 22) Prepararemos la siguiente estructura de directorios y archivos: fase-0 ansible playbooks deploy_wordpress.yml https.yml install_lamp.yml templates 000-default.conf.j2 dir.conf.j2 vars variables.yml inventario --> Archivo main.yml scripting conf 000-default.conf dir.conf scripts config-https.sh deploy_wordpress.sh install_lamp.sh variables.sh fase-1 ansible playbooks deploy_backend.yml deploy_wordpress.yml https.yml install_backend.yml install_frontend.yml templates 000-default.conf.j2 dir.conf.j2 vars variables.yml inventario --> Archivo main.yml scripting conf 000-default.conf dir.conf scripts deploy_backend.sh deploy_wordpress.sh https_frontend.sh install_backend.sh install_frontend.sh variables.sh fase-2 ansible playbooks deploy_backend.yml deploy_balancer.yml deploy_wordpress.yml https.yml install_backend.yml install_frontend.yml install_nfs_client.yml install_nfs_server.yml templates 000-default-balancer.conf.j2 000-default-frontend.conf.j2 dir.conf.j2 exports.j2 vars variables.yml inventario --> Archivo main.yml scripting conf 000-default-balancer.conf 000-default-frontend.conf dir.conf exports scripts deploy_backend.sh deploy_balancer.sh deploy_wordpress.sh https_balancer.sh install_backend.sh install_frontend.sh install_nfs_client.sh install_nfs_server.sh variables.sh Crearemos un repositorio para la pr\u00e1ctica. Warning Las im\u00e1genes pueden que funcionen o no fase-0 \u00b6 Iniciaremos esta pr\u00e1ctica explicando la primera fase, mediante scripting como con ansible. Crearemos en No-IP un dominio asignado a una direcci\u00f3n IP. scripting \u00b6 Una vez tengamos la estructura de directorios y archivos necesarios, empezaremos con los archivos que tenemos que nos sirven de plantillas para usar una configuraci\u00f3n concreta en la instancia. 000-default.conf \u00b6 Este archivo lo necesitaremos para permitir la creaci\u00f3n de archivos htaccess mediante AllowOverride All y permitir que el sitio web funcione correctamente. <VirtualHost *:80> ServerAdmin webmaster@localhost DocumentRoot /var/www/html #LogLevel info ssl:warm <Directory \"/var/www/html\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost> dir.conf \u00b6 Con este archivo priorizaremos el archivo index.php sobre el resto de los archivos. <IfModule mod_dir.c> DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm </IfModule> variables.sh \u00b6 Este archivo nos permitir\u00e1 tener variables globales para los scripts que las necesiten y no tener que cambiar el contenido de las variables en varios archivos. DB_Name=wp_db DB_User=wp_user DB_Password=wp_pass DB_Host=localhost WP_Home=https://practicasiaw09jrrl.ddns.net WP_SiteURL=https://practicasiaw09jrrl.ddns.net/wordpress Certbot_Email=tetz_dqhwr17@yutep.com Certbot_Domain=practicasiaw09jrrl.ddns.net Las tres primeras l\u00edneas nos permiten establecer la base de datos con el usuario y la contrase\u00f1a para ese usuario, la cuarta nos permite indicar d\u00f3nde se encuentra la base de datos, en nuestro caso como est\u00e1 en la misma m\u00e1quina ser\u00e1 localhost. La cuarta variable nos permite indicar el formato de la URL que queremos para nuestro sitio web , la quinta variable establece la ruta local d\u00f3nde se encuentra la instalaci\u00f3n de WordPress , las dos \u00faltimas variables son para la obtenci\u00f3n del certificado de Let's Encrypt usando Certbot. install_lamp.sh \u00b6 Instalaremos la pila LAMP en nuestra instancia, tambi\u00e9n copiaremos las dos plantillas a su respectiva ruta, habilitaremos el m\u00f3dulo rewrite para que WordPress pueda hacer cambios y reiniciaremos el servidor Apache2 para aplicar los cambios realizados. apt-get update apt-get upgrade -y apt-get install apache2 -y apt-get install mysql-server -y apt-get install php libapache2-mod-php php-mysql -y Como de costumbre, seguiremos los mismos pasos para la instalaci\u00f3n de la pila LAMP. cp ../conf/000-default.conf /etc/apache2/sites-available cp ../conf/dir.conf /etc/apache2/mods-available a2enmod rewrite systemctl restart apache2 A continuaci\u00f3n, copiaremos la primera plantilla , 000-default.conf a la ruta /etc/apache2/sites-available para permitir el uso de archivos .htaccess y que nuestro sitio web funcione correctamente en cuanto al contenido servido. Copiaremos la segunda plantilla , dir.conf a la ruta /etc/apache2/mods-available para priorizar los archivos index seg\u00fan formato, luego habilitaremos el m\u00f3dulo rewrite de Apache y reiniciaremos el servidor web. config-https.sh \u00b6 Este segundo script nos permitir\u00e1 la configuraci\u00f3n del servidor para usar el protocolo HTTPS, tendremos que instalar Certbot mediante Snap y obtener el certificado de Let's Encrypt. Este script lo hemos realizado en pr\u00e1cticas anteriores, por lo que realizar\u00e9 una explicaci\u00f3n superficial del script source variables.sh snap install core snap refresh core apt-get remove Certbot snap install --classic Certbot ln -s /snap/bin/certbot /usr/bin/certbot certbot --apache -m $Certbot_Email --agree-tos --no-eff-email -d $Certbot_Domain Importaremos el archivo de variables e instalaremos Core mediante Snap, despu\u00e9s actualizaremos Core y quitaremos la instalaci\u00f3n por defecto de Certbot que viene con el sistema operativo, despu\u00e9s instalaremos Certbot mediante Snap y solicitaremos el certificado de Let's Encrypt. deploy_wordpress.sh \u00b6 Con este script realizaremos el despliegue de WordPress en la instancia, necesitaremos descargar el c\u00f3digo fuente de WordPress, as\u00ed como Unzip, crear una base de datos, descomprimir los archivos en /var/www/html y personalizar WordPress. source variables.sh wget https://wordpress.org/latest.zip -O /tmp/latest.zip apt install unzip -y unzip /tmp/latest.zip -d /var/www/html cp /var/www/html/wordpress/wp-config-sample.php /var/www/html/wordpress/wp-config.php sed -i \"s/database_name_here/$DB_Name/\" /var/www/html/wordpress/wp-config.php sed -i \"s/username_here/$DB_User/\" /var/www/html/wordpress/wp-config.php sed -i \"s/password_here/$DB_Password/\" /var/www/html/wordpress/wp-config.php sed -i \"s/localhost/$DB_Host/\" /var/www/html/wordpress/wp-config.php En esta parte del script realizaremos la importaci\u00f3n de las variables definidas, despu\u00e9s descargaremos el c\u00f3digo fuente de WordPress, instalaremos Unzip y descomprimiremos el contenido en /var/www/html, de forma que en la ruta deberemos tener tanto index.html como un directorio llamado wordpress . A continuaci\u00f3n, copiaremos el archivo wp-config-sample.php en la misma ruta con distinto nombre para realizar modificaciones sobre la copia, wp-config.php . Las modificaciones que deberemos hacer son la asignaci\u00f3n de la base de datos, el usuario y su contrase\u00f1a y la localizaci\u00f3n de la base de datos. echo \"DROP DATABASE IF EXISTS $DB_Name\" | mysql -u root echo \"CREATE DATABASE $DB_Name CHARACTER SET utf8mb4\" | mysql -u root echo \"DROP USER IF EXISTS $DB_User@'%'\" | mysql -u root echo \"CREATE USER $DB_User@'%' IDENTIFIED BY '$DB_Password'\" | mysql -u root echo \"GRANT ALL PRIVILEGES ON $DB_Name.* TO $DB_User@'%'\" | mysql -u root cp /var/www/html/wordpress/index.php /var/www/html sed -i \"s|wp-blog-header.php|wordpress/wp-blog-header.php|\" /var/www/html/index.php sed -i \"/DB_COLLATE/a define('WP_HOME', '$WP_Home');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_HOME/a define('WP_SITEURL', '$WP_SiteURL');\" /var/www/html/wordpress/wp-config.php chown www-data:www-data -R /var/www/html Despu\u00e9s, crearemos la base de datos junto al usuario y su contrase\u00f1a y copiaremos el archivo index.php para ponerlo en un nivel superior , en /var/www/html para que en cuanto se acceda al dominio o a la direcci\u00f3n IP del servidor se acceda directamente sin tener que referenciar el directorio de instalaci\u00f3n de WordPress en el equipo . Por \u00faltimo, modificaremos el index.php para hacer referencia a la localizaci\u00f3n del archivo wp-blog-header.php y que nuestro WordPress funcione correctamente. Tambi\u00e9n modificaremos el contenido del archivo wp-config.php para a\u00f1adir un par de l\u00edneas que indicar\u00e1n el formato de URL que tendr\u00e1 el sitio y la ruta interna a los archivos de WordPress , adem\u00e1s de cambiar el propietario y el grupo de html de forma recursiva. ansible \u00b6 Realizaremos la misma parte mediante ansible, de forma que modificaremos lo realizado mediante scripting para ajustarlo al uso de Ansible. variables.yml \u00b6 En este archivo tendremos las variables para usarlas en los playbooks que las necesiten. Certbot: Email: tetz_dqhwr17@yutep.com Domain: practicasiaw09jrrl.ddns.net Template_000_default: Local_Source: ../templates/000-default.conf.j2 DocumentRoot: /var/www/html Template_dir: Local_Source: ../templates/dir.conf.j2 Directory_index: DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm PHP_Packages: - php - libapache2-mod-php - php-mysql Database: Name: wordpress_db User: wordpress_user Password: wordpress_pass Host: localhost WordPress: Home: http://practicasiaw09jrrl.ddns.net SiteURL: http://practicasiaw09jrrl.ddns.net/wordpress Introduciremos las variables que necesitamos dentro de otra variable que ser\u00e1 la global para tenerlas agrupadas por funci\u00f3n o m\u00e1quina d\u00f3nde se ejecutar\u00e1n. De esta forma evitamos tener variables sueltas y evitamos el caos resultante. Las dos primeras variables nos servir\u00e1n para la obtenci\u00f3n del certificado de Let's Encrypt y poder usar HTTPS, la tercera indica la ruta local del template 000-default.conf.j2 y la cuarta el contenido de la variable de dicho template. La quinta indica la ruta local del template dir.conf.j2 y la sexta el contenido de la variable de dicho template, en la s\u00e9ptima variable indicamos los paquetes de PHP que hay que instalar. Las siguientes cuatro variables son para indicar la base de datos, el usuario y su contrase\u00f1a y la localizaci\u00f3n de la base de datos. Las dos \u00fa ltimas son para la personalizaci\u00f3n de la URL de WordPress y la ruta interna de los archivos de WordPress en el equipo. 000-default.conf.j2 \u00b6 Al igual que hicimos con los scripts, crearemos una plantilla o template para copiar el template en el equipo local al equipo remoto y haremos unas modificaciones mediante variables, que en este caso, tenemos que hacer referencia a la variable global seguido de un punto (o dot) seguido de la variable que tiene el contenido que necesitamos . <VirtualHost *:80> #ServerName www.example.org ServerAdmin webmaster@localhost DocumentRoot {{ Template_000_default.DocumentRoot }} #LogLevel info ssl:warm <Directory \"{{ Template_000_default.DocumentRoot }}\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost> El contenido del template es lo mismo, salvo que usaremos una variable para definir el directorio de localizaci\u00f3n de WordPress y si fuese necesario podr\u00edamos modificar el contenido de la variable sin tener que modificar el template. dir.conf.j2 \u00b6 Al igual que con el scripting, priorizaremos las extensiones de los archivos index para que primero se nos muestre primero el index.php sobre el index.html. <IfModule mod_dir.c> {{ Template_dir.Directory_index }} </IfModule> inventario \u00b6 Definiremos los par\u00e1metros globales para el usuario de la instancia, la localizaci\u00f3n de la clave privada de la instancia en el equipo local y que no nos pregunte si queremos a\u00f1adir el fingerprint o huella de la m\u00e1quina. Tambi\u00e9n especificaremos el grupo wordpress y la direcci\u00f3n IP que tiene la instancia en el momento de crearla o la direcci\u00f3n IP el\u00e1stica si asignamos una a la instancia. [wordpress] 18.204.227.200 [wordpress:vars] ansible_user=ubuntu ansible_ssh_private_key_file=/home/rayseink/claves/vockey.pem ansible_ssh_common_args='-o StrictHostKeyChecking=accept-new' install_lamp.yml \u00b6 Realizaremos la instalaci\u00f3n de la pila LAMP y pasaremos los templates al equipo remoto, habilitaremos el m\u00f3dulo rewrite y reiniciaremos el servidor Apache2. --- - name: Playbook para el despliegue de la pila LAMP hosts: wordpress become: true tasks: - name: Inclusi\u00f3n de variables para los templates ansible.builtin.include_vars: ../vars/variables.yml - name: Actualizaci\u00f3n de los repositorios ansible.builtin.apt: update_cache: true upgrade: true - name: Instalaci\u00f3n del servidor web Apache2 ansible.builtin.apt: name: apache2 state: present - name: Instalaci\u00f3n del servidor de bases de datos ansible.builtin.apt: name: mysql-server state: present - name: Instalaci\u00f3n de PHP y m\u00f3dulos para conectar con la base de datos y Apache2 ansible.builtin.apt: name: \"{{ PHP_Packages }}\" state: present Hasta aqu\u00ed es la inclusi\u00f3n del archivo de variables en el playbook para los dos templates que vamos a pasar al servidor, la actualizaci\u00f3n de los repositorios y los programas con respecto a los repositorios, la instalaci\u00f3n de Apache2, MySQL Server y los paquetes de PHP. - name: Copiado del template 000-default.conf.j2 a la ruta /etc/apache2/sites-available ansible.builtin.template: src: \"{{ Template_000_default.Local_Source }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 - name: Copiado del template dir.conf.j2 a la ruta /etc/apache2/mods-available ansible.builtin.template: src: \"{{ Template_dir.Local_Source }}\" dest: /etc/apache2/mods-available/dir.conf mode: 0644 - name: Habilitaci\u00f3n del m\u00f3dulo rewrite de Apache2 community.general.apache2_module: name: rewrite state: present notify: Reiniciar servidor Apache2 handlers: - name: Reiniciar servidor Apache2 ansible.builtin.service: name: apache2 state: restarted Usaremos el m\u00f3dulo ansible.builtin.template para pasar los templates locales al servidor y habilitaremos el m\u00f3dulo rewrite de Apache2 para que WordPress pueda realizar cambios en el servidor web, por \u00faltimo reiniciaremos Apache2 para que se apliquen los cambios. https.yml \u00b6 Con este playbook realizaremos la descarga de Certbot y la obtenci\u00f3n del certificado de Let's Encrypt para poder usar HTTPS en nuestro servidor. --- - name: Descarga de Certbot mediante Snap y obtenci\u00f3n de certificado de Let's Encrypt hosts: wordpress become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Desinstalaci\u00f3n de la instalaci\u00f3n previa de Certbot que viene con el sistema operativo ansible.builtin.apt: name: certbot state: absent - name: Instalaci\u00f3n de Certbot mediante Snap community.general.snap: name: certbot classic: true state: present - name: Descarga de certificado para TLS / SSL ansible.builtin.command: certbot --apache -m \"{{ Certbot_Email }}\" --agree-tos --no-eff-email -d \"{{ Certbot_Domain }}\" register: realizar_cambio changed_when: realizar_cambio.rc == 0 Incluiremos el archivo de variables en el playbook y desinstalaremos Certbot que viene con el sistema operativo, despu\u00e9s instalaremos mediante Snap la versi\u00f3n correcta de Certbot y obtendremos el certificado de Let's Encrypt. deploy_wordpress.yml \u00b6 Realizaremos el despliegue de WordPress en el equipo remoto, crearemos una base de datos con un usuario y una contrase\u00f1a y haremos las modificaciones pertinentes para WordPress. --- - name: Despliegue de WordPress en un \u00fanico nodo hosts: wordpress become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n de Unzip para descomprimir archivos ansible.builtin.apt: name: unzip state: present - name: Descarga del c\u00f3digo fuente de WordPress en directorio temporal ansible.builtin.get_url: url: https://wordpress.org/latest.zip dest: /tmp/wordpress.zip mode: 664 - name: Descompresi\u00f3n de WordPress en /var/www/html ansible.builtin.unarchive: src: /tmp/wordpress.zip dest: /var/www/html remote_src: true - name: Borrado del archivo comprimido en el directorio temporal ansible.builtin.file: path: /tmp/wordpress.zip state: absent - name: Copiado de archivo wp-config-sample.php a wp-config.php ansible.builtin.copy: src: /var/www/html/wordpress/wp-config-sample.php dest: /var/www/html/wordpress/wp-config.php mode: 0644 remote_src: true Empezaremos incluyendo el archivo de variables en el playbook, despu\u00e9s instalaremos Unzip para la descompresi\u00f3n de archivos, descargaremos el c\u00f3digo fuente de WordPress en el directorio temporal, descomprimiremos el archivo de WordPress en /var/www/html, borraremos el archivo comprimido que contiene WordPress y copiaremos el archivo wp-config-sample.php en la misma ruta para modificar el nombre del archivo a wp-config.php usando el m\u00f3dulo ansible.builtin.copy y con la opci\u00f3n remote_src: true para indicar que es en el equipo remoto . - name: Modificaci\u00f3n del archivo wp-config.php para especificar la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: database_name_here replace: \"{{ Database.Name }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el usuario de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: username_here replace: \"{{ Database.User }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar la contrase\u00f1a del usuario ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: password_here replace: \"{{ Database.Password }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el servidor de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: localhost replace: \"{{ Database.Host }}\" Modificaremos el archivo wp-config.php para indicar la base de datos, el usuario de la base de datos y su contrase\u00f1a, adem\u00e1s de la conexi\u00f3n a la base de datos, que en este caso es localhost. - name: Instalaci\u00f3n del gestor de paquetes de Python3 ansible.builtin.apt: name: python3-pip state: present - name: Instalaci\u00f3n del m\u00f3dulo PyMySQL mediante el gestor de paquetes de Python3 para conectar conectar con el socket ansible.builtin.pip: name: pymysql state: present - name: Creaci\u00f3n de la base de datos usando el socket de PyMySQL community.mysql.mysql_db: name: \"{{ Database.Name }}\" state: present login_unix_socket: /run/mysqld/mysqld.sock - name: Creaci\u00f3n del usuario con la contrase\u00f1a para la base de datos no_log: true community.mysql.mysql_user: name: \"{{ Database.User }}\" host: '%' password: \"{{ Database.Password }}\" priv: \"{{ Database.Name }}.*:ALL\" state: present login_unix_socket: /run/mysqld/mysqld.sock A continuaci\u00f3n, crearemos la base de datos con el usuario y la contrase\u00f1a, para ello, necesitamos instalar en el equipo remoto el gestor de paquetes de Python3 y el m\u00f3dulo PyMySQL . Para la base de datos con el usuario y contrase\u00f1a necesitaremos usar el socket de MySQL (mysqld.sock) que se encuentra en /run/mysqld para poder realizar las operaciones pertinentes usando el m\u00f3dulo PyMySQL . - name: Copiado del archivo index.php de html/wordpress a html ansible.builtin.copy: src: /var/www/html/wordpress/index.php dest: /var/www/html/index.php mode: 0644 remote_src: true - name: Modificaci\u00f3n del archivo index.php para la redirecci\u00f3n a WordPress ansible.builtin.replace: path: /var/www/html/index.php regexp: wp-blog-header.php replace: wordpress/wp-blog-header.php - name: Modificaci\u00f3n del archivo wp-config.php para la personalizaci\u00f3n de la URL ansible.builtin.blockinfile: path: /var/www/html/wordpress/wp-config.php insertafter: DB_COLLATE block: | define('WP_HOME', '{{ WordPress.Home }}'); define('WP_SITEURL', '{{ WordPress.SiteURL }}'); - name: Cambio de propietario y grupo para /var/www/html ansible.builtin.file: path: /var/www/html owner: www-data group: www-data recurse: true notify: Reinicio de Apache2 handlers: - name: Reinicio de Apache2 ansible.builtin.service: name: apache2 state: restarted Para finalizar con el playbook, subiremos un nivel el archivo index.php que se encuentra en /var/www/html/wordpress y lo modificaremos para indicar la ruta al archivo wp-blog-header.php que se encuentra en el directorio wordpress . Tambi\u00e9n modificaremos el archivo wp-config.php para personalizar la URL de WordPress y evitar que aparezca el directorio d\u00f3nde se ubica, usaremos el m\u00f3dulo ansible.builtin.blockinfile , indicaremos la ruta del archivo y que vamos a a\u00f1adir un bloque de c\u00f3digo despu\u00e9s de la l\u00ednea que contenga DB_COLLATE con insertafter y con block las l\u00edneas que queremos a\u00f1adir , la primera para indicar el formato de la URL y la segunda la ubicaci\u00f3n interna de WordPress. A continuaci\u00f3n, cambiaremos el propietario y el grupo de la ruta /var/www/html de forma recursiva y provocaremos el reinicio de Apache2 mediante notify y el handler correspondiente. main.yml \u00b6 Este archivo ser\u00e1 el que importar\u00e1 los playbooks y el que ejecutemos para realizar la instalaci\u00f3n de la pila LAMP, la configuraci\u00f3n para HTTPS y el despliegue de WordPress. Usaremos tags para cada importaci\u00f3n de playbook ya que si queremos evitar que un playbook o playbooks se ejecuten tenemos que hacer referencia al tag o tags que no queremos que se ejecuten , como por ejemplo el playbook https, tambi\u00e9n podemos hacer el caso contrario de ejecutar un playbook o playbooks mediante el tag o tags , los tags tambi\u00e9n nos permiten referenciar cada task o playbook para su identificaci\u00f3n. --- - name: Importaci\u00f3n de playbook para instalar la pila LAMP ansible.builtin.import_playbook: playbooks/install_lamp.yml tags: lamp - name: Importaci\u00f3n de playbook para preparar HTTPS import_playbook: playbooks/https.yml tags: certificado - name: Importaci\u00f3n de playbook para el despliegue de wordpress ansible.builtin.import_playbook: playbooks/deploy_wordpress.yml tags: wordpress El orden de ejecuci\u00f3n es primero pila LAMP, despu\u00e9s la obtenci\u00f3n del certificado de Let's Encrypt ya que para este playbook necesitamos tener instalado Apache y por \u00faltimo el despliegue de WordPress. Comprobaci\u00f3n del despliegue de WordPress en un nivel \u00b6 Como tenemos dos formas de realizar esta fase, escogeremos la que queramos, podemos hacerlo mediante scripting que deberemos clonar el repositorio en el que hemos realizado los scripts al equipo en el que instalaremos WordPress o con ansible desde nuestro equipo local lanzando el archivo main.yml. Debemos tener en cuenta el orden de ejecuci\u00f3n de los scripts y de los playbooks , por ejemplo, para obtener el certificado de Let's Encrypt, necesitamos que la m\u00e1quina tenga instalado el servidor Apache . Mediante scripting tenemos que ejecutar los scripts en el siguiente orden y en la ruta d\u00f3nde se encuentran : sudo ./install_lamp.sh sudo ./config-https.sh sudo ./deploy_wordpress.sh Mediante ansible en la ruta d\u00f3nde se encuentra el archivo inventario y main.yml : ansible-playbook -i inventario main.yml De la forma anterior con Ansible ejecutamos todos los playbooks y en el caso de que queramos saltar un playbook, como por ejemplo la instalaci\u00f3n de Certbot mediante Snap y la descarga del certificado de Let's Encrypt, usaremos: ansible-playbook -i inventario main.yml --skip-tags certificado Para el caso contrario, s\u00f3lo tenemos que ejecutar: ansible-playbook -i inventario main.yml --tags [lamp, wordpress] Una vez lancemos la instalaci\u00f3n de una forma u otra, cuando termine la ejecuci\u00f3n, accederemos a trav\u00e9s de un navegador web a la direcci\u00f3n IP de la instancia o mediante el dominio que hemos asignado. Nos saldr\u00e1 el idioma que queremos para nuestro WordPress, lo escogemos y pasamos al siguiente paso. Cuando terminemos de poner los datos que nos piden, pulsaremos en el bot\u00f3n Instalar WordPress. Cuando hayamos accedido al backoffice, usaremos el dominio en una pesta\u00f1a nueva para comprobar que funciona correctamente. fase-1 \u00b6 Para esta fase necesitaremos dos equipos, un frontend y un backend, en este caso como no necesitamos balanceador de carga, por lo que tendremos que abrir los puertos de HTTPS, HTTP y SSH en la m\u00e1quina frontend. Crearemos un nuevo dominio y asignaremos la direcci\u00f3n IP p\u00fablica de la m\u00e1quina frontend o asignaremos una direcci\u00f3n IP el\u00e1stica a la m\u00e1quina y asignaremos la IP al dominio en No-IP. Parte de los archivos que hemos usado en la anterior fase los reutilizaremos y el resto los modificaremos y partiremos el contenido para adecuarlo a los dos niveles de esta parte. scripting \u00b6 Los archivos variables.sh, config-https.sh, 000-default.conf y dir.conf los reutilizaremos y en el caso de config-https.sh lo renombraremos a https_frontend.sh ya que tenemos que obtener el certificado de Let's Encrypt en la m\u00e1quina frontend. Modificaremos el contenido de ambos scripts para que se adec\u00faen a las dos nuevas m\u00e1quinas que tenemos que crear. Los dem\u00e1s scripts los partiremos para que cada m\u00e1quina realice su funci\u00f3n. En el archivo variables.sh hay una l\u00ednea que tenemos que modificar . DB_Host=172.31.66.200 Certbot_Domain=practica09iawjrrl.ddns.net WP_Home=https://practica09iawjrrl.ddns.net WP_SiteURL=https://practica09iawjrrl.ddns.net/wordpress En la variable DB_Host tenemos que poner la direcci\u00f3n IP privada de la m\u00e1quina backend ya que es la que tendr\u00e1 el servidor MySQL para la base de datos con el usuario y la contrase\u00f1a, tambi\u00e9n podemos modificar el dominio de las variables Certbot_Domain, WP_Home y WP_SiteURL . install_frontend.sh \u00b6 En esta m\u00e1quina tenemos que actualizar los repositorios y los programas instalados, instalar el servidor web Apache y los paquetes relacionados con PHP, adem\u00e1s de copiar las plantillas a sus respectivos directorios, habilitar el m\u00f3dulo rewrite y reiniciar el servidor web para aplicar los cambios. Deber\u00e1 quedar de la siguiente manera: apt-get update apt-get upgrade -y apt-get install apache2 -y apt-get install php libapache2-mod-php php-mysql -y cp ../conf/000-default.conf /etc/apache2/sites-available cp ../conf/dir.conf /etc/apache2/mods-available a2enmod rewrite systemctl restart apache2 En la m\u00e1quina frontend no instalaremos el servidor de bases de datos MySQL ya que esta instalaci\u00f3n la realizaremos en la m\u00e1quina backend. install_backend.sh \u00b6 En esta m\u00e1quina tendremos que actualizar los repositorios y los programas con respecto a los repositorios instalados y realizar la instalaci\u00f3n de MySQL y cambiar el Bind-Address para aceptar conexiones de otras m\u00e1quinas. apt-get update apt-get upgrade -y apt-get install mysql-server sed -i 's/127.0.0.1/0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf systemctl restart mysql Como esta m\u00e1quina ser\u00e1 la que tenga la base de datos de WordPress, tendremos que instalar MySQL y hacer un cambio en el Bind-Address para que acepte conexiones de nuestra m\u00e1quina frontend. Para finalizar, tendremos que reiniciar MySQL para que los cambios se apliquen. deploy_wordpress.sh \u00b6 Usaremos este script para descargar y desplegar WordPress en la m\u00e1quina frontend, de forma que tendremos que realizar cambios en el archivo wp-config.php para especificar el nombre de la base de datos, el usuario a usar y su contrase\u00f1a, tambi\u00e9n debemos especificar la m\u00e1quina en la que se encuentra MySQL. source variables.sh wget https://wordpress.org/latest.zip -O /tmp/latest.zip apt install unzip -y unzip /tmp/latest.zip -d /var/www/html cp /var/www/html/wordpress/wp-config-sample.php /var/www/html/wordpress/wp-config.php sed -i \"s/database_name_here/$DB_Name/\" /var/www/html/wordpress/wp-config.php sed -i \"s/username_here/$DB_User/\" /var/www/html/wordpress/wp-config.php sed -i \"s/password_here/$DB_Password/\" /var/www/html/wordpress/wp-config.php sed -i \"s/localhost/$DB_Host/\" /var/www/html/wordpress/wp-config.php cp /var/www/html/wordpress/index.php /var/www/html sed -i \"s|wp-blog-header.php|wordpress/wp-blog-header.php|\" /var/www/html/index.php sed -i \"/DB_COLLATE/a define('WP_HOME', '$WP_Home');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_HOME/a define('WP_SITEURL', '$WP_SiteURL');\" /var/www/html/wordpress/wp-config.php chown www-data:www-data -R /var/www/html En este script tenemos que importar el archivo de variables e iniciar la descarga del c\u00f3digo fuente de WordPress, instalar Unzip y descomprimir el contenido de WordPress descargado en la m\u00e1quina en el directorio /var/www/html, despu\u00e9s cambiaremos el nombre del archivo wp-config-sample.php a wp-config.php para que coja la configuraci\u00f3n del archivo que vamos a modificar para especificar la base de datos, el usuario, su contrase\u00f1a y la ubicaci\u00f3n de la base de datos. Despu\u00e9s subiremos un nivel el archivo index.php para ubicarlo en /var/www/html. Modificaremos el index.php para especificar la ubicaci\u00f3n del archivo wp-blog-header.php que se encuentra en /var/www/html/wordpress y volveremos a modificar el archivo wp-config.php para a\u00f1adir dos l\u00edneas, la primera nos permite especificar la URL que tendr\u00e1 el sitio web y la segunda la ubicaci\u00f3n interna de los archivos de WordPress. Por \u00faltimo, modificaremos el propietario y el grupo de los archivos y directorios que se encuentran en /var/www/html de forma recursiva a Apache. deploy_backend.sh \u00b6 Este script lo usaremos para crear la base de datos en el equipo backend. source variables.sh echo \"DROP DATABASE IF EXISTS $DB_Name\" | mysql -u root echo \"CREATE DATABASE $DB_Name CHARACTER SET utf8mb4\" | mysql -u root echo \"DROP USER IF EXISTS $DB_User@'%'\" | mysql -u root echo \"CREATE USER $DB_User@'%' IDENTIFIED BY '$DB_Password'\" | mysql -u root echo \"GRANT ALL PRIVILEGES ON $DB_Name.* TO $DB_User@'%'\" | mysql -u root Importaremos el archivo de variables y crearemos tanto la base de datos con el usuario y la contrase\u00f1a, tambi\u00e9n especificaremos los privilegios que tendr\u00e1 el usuario con respecto la base de datos, en este caso tendr\u00e1 todos los privilegios. ansible \u00b6 En este caso tambi\u00e9n reutilizaremos los archivos variables.yml , 000-default.conf.j2 , dir.conf.j2 y https.yml , en el caso del archivo variables.yml tendremos que modificar el contenido de algunas de las variables que tenemos para adecuarlas a las m\u00e1quinas y en el caso de https.yml tenemos que modificar la l\u00ednea de hosts para que se ejecute en la m\u00e1quina frontend . variables.yml \u00b6 Modificaremos el contenido de las siguientes variables para adecuarlo a la nueva fase, siendo opcionales tanto Domain, Home y SiteURL . Host: 172.31.66.200 Domain: practica09iawjrrl.ddns.net Home: https://practicasiaw09jrrl.ddns.net SiteURL: https://practicasiaw09jrrl.ddns.net/wordpress En la variable Host tenemos que poner la direcci\u00f3n IP privada de la m\u00e1quina que tendr\u00e1 el servidor de bases de datos . inventario \u00b6 En este archivo definiremos dos grupos, uno para la m\u00e1quina frontend y otro para la m\u00e1quina backend. [frontend] 3.231.218.67 [backend] 35.168.113.213 [all:vars] ansible_user=ubuntu ansible_ssh_private_key_file=/home/rayseink/claves/vockey.pem ansible_ssh_common_args='-o StrictHostKeyChecking=accept-new' Como necesitamos hacer la ejecuci\u00f3n de cada playbook en su m\u00e1quina correspondiente, tenemos que tener dos grupos en nuestro archivo de inventario y con la direcci\u00f3n IP p\u00fablica de la m\u00e1quina en su respectivo grupo. Por \u00faltimo, tenemos que usar all:vars para que la configuraci\u00f3n global la coja todos los grupos de m\u00e1quinas que hemos especificado. install_frontend.yml \u00b6 Al igual que hicimos con los scripts, tenemos que instalar en la m\u00e1quina frontend el servidor Apache, PHP y sus respectivos m\u00f3dulos, copiar los templates locales a la m\u00e1quina remota, habilitar el m\u00f3dulo rewrite para que WordPress pueda realizar cambios en el servidor web y reiniciar el servidor web. --- - name: Instalaci\u00f3n de Apache y PHP para el equipo frontend hosts: frontend become: true tasks: - name: Inclusi\u00f3n de archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Actualizaci\u00f3n de los repositorios y de los programas instalados ansible.builtin.apt: update_cache: true upgrade: true - name: Instalaci\u00f3n de servidor web Apache ansible.builtin.apt: name: apache2 state: present - name: Instalaci\u00f3n de PHP y m\u00f3dulos de PHP para conectar con la base de datos y Apache ansible.builtin.apt: name: \"{{ PHP_Packages }}\" state: present - name: Copiado de template 000-default.conf.j2 al equipo remoto ansible.builtin.template: src: \"{{ Template_000_default.Local_Source }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 - name: Copiado de template dir.conf.j2 al equipo remoto ansible.builtin.template: src: \"{{ Template_dir.Local_Source }}\" dest: /etc/apache2/mods-available/dir.conf mode: 0644 - name: Habilitaci\u00f3n del m\u00f3dulo rewrite de Apache community.general.apache2_module: name: rewrite state: present notify: Reiniciar servidor Apache handlers: - name: Reiniciar servidor Apache ansible.builtin.service: name: apache2 state: restarted Tenemos que especificar en hosts el grupo en el que se ejecutar\u00e1 este playbook y como hicimos con los scripts, realizaremos los cambios pertinentes para preparar la m\u00e1quina frontend. install_backend.yml \u00b6 En este playbook tenemos que instalar MySQL y modificar el Bind-Address para que acepte conexiones de la red y reiniciar el servidor de bases de datos para que aplique el cambio realizado. --- - name: Instalaci\u00f3n de MySQL Server y cambio de Bind-Address hosts: backend become: true tasks: - name: Actualizaci\u00f3n de los repositorios y de los programas instalados ansible.builtin.apt: update_cache: true upgrade: true - name: Instalaci\u00f3n de MySQL Server ansible.builtin.apt: name: mysql-server state: present - name: Cambio de Bind-Address para conectar con el equipo frontend ansible.builtin.replace: path: /etc/mysql/mysql.conf.d/mysqld.cnf regexp: 127.0.0.1 replace: 0.0.0.0 notify: Reiniciar servidor MySQL handlers: - name: Reiniciar servidor MySQL ansible.builtin.service: name: mysql state: restarted Al igual que hicimos con el anterior playbook, tenemos que especificar en hosts el grupo en el que se ejecutar\u00e1 este playbook . https.yml \u00b6 Este archivo lo tenemos que ejecutar en la m\u00e1quina frontend , de forma que modificaremos la l\u00ednea de hosts para que se ejecute en el grupo frontend del archivo inventario. --- - name: Descarga de Certbot mediante Snap y obtenci\u00f3n de certificado de Let's Encrypt hosts: frontend become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Desinstalaci\u00f3n de la instalaci\u00f3n previa de Certbot que viene con el sistema operativo ansible.builtin.apt: name: certbot state: absent - name: Instalaci\u00f3n de Certbot mediante Snap community.general.snap: name: certbot classic: true state: present - name: Descarga de certificado para TLS / SSL ansible.builtin.command: certbot --apache -m \"{{ Certbot.Email }}\" --agree-tos --no-eff-email -d \"{{ Certbot.Domain }}\" register: realizar_cambio changed_when: realizar_cambio.rc == 0 when: certificado | d(False) == \"descargar\" Usaremos para evitar la ejecuci\u00f3n de la descarga del certificado de Let's Encrypt el Statement When , pondremos el When al mismo nivel y justamente despu\u00e9s de la tarea concreta y usaremos una variable , certificado que por defecto no se ejecutar\u00e1 hasta que el contenido de la variable sea \"descargar\" . deploy_wordpress.yml \u00b6 Este playbook lo ejecutaremos en la m\u00e1quina frontend y nos servir\u00e1 para descargar el c\u00f3digo fuente de WordPress, descomprimirlo y conectar con la base de datos que se encuentra en el equipo backend. --- - name: Despliegue de WordPress en el equipo frontend hosts: frontend become: true tasks: - name: Inclusi\u00f3n de archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n de Unzip ansible.builtin.apt: name: unzip state: present - name: Descarga del c\u00f3digo fuente de WordPress ansible.builtin.get_url: url: https://wordpress.org/latest.zip dest: /tmp/wordpress.zip mode: 0664 - name: Descompresi\u00f3n de la descarga de WordPress ansible.builtin.unarchive: src: /tmp/wordpress.zip dest: /var/www/html remote_src: true - name: Borrado del archivo comprimido de WordPress ansible.builtin.file: path: /tmp/wordpress.zip state: absent - name: Copiado de archivo wp-config-sample.php a wp-config.php ansible.builtin.copy: src: /var/www/html/wordpress/wp-config-sample.php dest: /var/www/html/wordpress/wp-config.php mode: 0644 remote_src: true - name: Modificaci\u00f3n del archivo wp-config.php para especificar la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: database_name_here replace: \"{{ Database.Name }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el usuario de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: username_here replace: \"{{ Database.User }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar la contrase\u00f1a del usuario ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: password_here replace: \"{{ Database.Password }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el servidor de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: localhost replace: \"{{ Database.Host }}\" - name: Copiado del archivo index.php de html/wordpress a html ansible.builtin.copy: src: /var/www/html/wordpress/index.php dest: /var/www/html/index.php mode: 0644 remote_src: true - name: Modificaci\u00f3n del archivo index.php para la redirecci\u00f3n a WordPress ansible.builtin.replace: path: /var/www/html/index.php regexp: wp-blog-header.php replace: wordpress/wp-blog-header.php - name: Modificaci\u00f3n del archivo wp-config.php para la personalizaci\u00f3n de la URL ansible.builtin.blockinfile: path: /var/www/html/wordpress/wp-config.php insertafter: DB_COLLATE block: | define('WP_HOME', '{{ WordPress.Home }}'); define('WP_SITEURL', '{{ WordPress.SiteURL }}'); - name: Cambio de propietario y grupo para /var/www/html ansible.builtin.file: path: /var/www/html owner: www-data group: www-data recurse: true notify: Reinicio de Apache2 handlers: - name: Reinicio de Apache2 ansible.builtin.service: name: apache2 state: restarted deploy_backend.yml \u00b6 Con este \u00faltimo playbook, crearemos la base de datos junto al usuario y su contrase\u00f1a en la m\u00e1quina backend. --- - name: Despliegue de la base de datos para WordPress en el equipo backend hosts: backend become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n del gestor de paquetes de Python3 ansible.builtin.apt: name: python3-pip state: present - name: Instalaci\u00f3n del m\u00f3dulo PyMySQL mediante el gestor de paquetes de Python3 para conectar conectar con el socket ansible.builtin.pip: name: pymysql state: present - name: Creaci\u00f3n de la base de datos usando el socket de PyMySQL community.mysql.mysql_db: name: \"{{ Database.Name }}\" state: present login_unix_socket: /run/mysqld/mysqld.sock - name: Creaci\u00f3n del usuario con la contrase\u00f1a para la base de datos no_log: true community.mysql.mysql_user: name: \"{{ Database.User }}\" host: '%' password: \"{{ Database.Password }}\" priv: \"{{ Database.Name }}.*:ALL\" state: present login_unix_socket: /run/mysqld/mysqld.sock main.yml \u00b6 En este archivo principal importaremos los playbooks para ejecutarlos. --- - name: Importaci\u00f3n del playbook de instalaci\u00f3n para el equipo frontend ansible.builtin.import_playbook: playbooks/install_frontend.yml - name: Importaci\u00f3n del playbook de instalaci\u00f3n para el equipo backend ansible.builtin.import_playbook: playbooks/install_backend.yml - name: Importaci\u00f3n del playbook de obtenci\u00f3n del certificado de Let's Encrypt ansible.builtin.import_playbook: playbooks/https.yml - name: Importaci\u00f3n del playbook para el despliegue en el equipo frontend ansible.builtin.import_playbook: playbooks/deploy_wordpress.yml - name: Importaci\u00f3n del playbook para el despliegue en el equipo backend ansible.builtin.import_playbook: playbooks/deploy_backend.yml Comprobaci\u00f3n del despliegue de WordPress en dos niveles \u00b6 Ejecutaremos bien los scripts concretos en los equipos clonando el repositorio en ambas m\u00e1quinas o lanzaremos el archivo principal y el inventario mediante ansible para preparar e instalar WordPress en dos niveles. Lo mejor es montar la arquitectura mediante ansible. Mediante scripts tenemos que acceder a las m\u00e1quinas mediante SSH y clonar el repositorio en ambas m\u00e1quinas y acceder a la fase-1 al directorio scripts. Deberemos tener en cuenta que hay scripts o playbooks que tienen que ejecutarse unos antes que otros , de forma que seguiremos el siguiente orden establecido para que funcione correctamente, por ejemplo, para obtener el certificado de Let's Encrypt necesitamos que la m\u00e1quina en la que se va a descargar tenga el servidor Apache instalado . En la m\u00e1quina frontend tenemos que ejecutar en el siguiente orden : sudo ./install_frontend.sh sudo ./https_frontend.sh sudo ./deploy_wordpress.sh En la m\u00e1quina backend tenemos que ejecutar en el siguiente orden : sudo ./install_backend.sh sudo ./deploy_backend.sh Mediante ansible tenemos que dirigirnos en la m\u00e1quina local al directorio fase-1 , d\u00f3nde se encuentra tanto inventario como main.yml . Con el siguiente comando evitamos ejecutar en el playbook https , la \u00faltima tarea que consiste en la descarga del certificado de Let's Encrypt , que nos sirve para ejecuciones posteriores de los playbooks en las mismas m\u00e1quina y siempre que una tenga un certificado de Let's Encrypt, ya que dejar\u00eda bloqueado el proceso de descarga del certificado al disponer la m\u00e1quina de uno. ansible-playbook -i inventario main.yml Para nuestra primera vez con esta fase necesitamos que nuestro frontend tenga el certificado, por lo que tenemos que ejecutar: ansible-playbook -i inventario main.yml --extra-vars \"certificado=descargar\" Una vez hayamos finalizado, accederemos mediante la direcci\u00f3n IP p\u00fablica o el nombre de dominio que hemos preparado en un navegador web. Escogeremos el idioma que queramos y continuaremos. Introduciremos el nombre del sitio, el usuario de acceso al BackOffice junto a su contrase\u00f1a y el email y pulsaremos en el bot\u00f3n de Instalar WordPress. Una vez hayamos terminado de instalar WordPress, introduciremos el nombre de dominio y comprobaremos que funciona correctamente el TLS. Si queremos comprobar que en nuestro equipo backend tenemos la base de datos, accederemos mediante SSH a la instancia y ejecutaremos el comando sudo mysql -u root , despu\u00e9s usaremos show databases; y veremos las bases de datos que tenemos, accederemos a nuestra base de datos que hemos definido en el archivo de variables mediante ansible o scripting mediante use nombre_base_datos , siendo en mi caso use wordpress_db y usaremos show tables; para mostrar las tablas de la base de datos, como no hemos creado ninguna tabla antes de la instalaci\u00f3n, no deber\u00edamos tener ninguna, pero tras la instalaci\u00f3n vemos que tenemos varias tablas creadas, por lo que la instalaci\u00f3n de la base de datos se ha realizado correctamente en la m\u00e1quina backend. Para confirmar, usaremos el comando ip a para ver la direcci\u00f3n IP privada que tiene nuestra m\u00e1quina backend en la interfaz eth0. fase-2 \u00b6 Para esta fase, deberemos tener un balanceador de carga, dos frontend, un backend y un NFS Server . Con esta parte, tendremos un balanceador de carga que ir\u00e1 conmutando las peticiones que reciba a los frontend y estos a su vez se conectar\u00e1n con el servidor NFS para servir las p\u00e1ginas que est\u00e1n almacenadas en el servidor NFS. Cuando tengamos listas las m\u00e1quinas, en No-IP crearemos un dominio con la direcci\u00f3n IP de la m\u00e1quina que har\u00e1 de balanceador de carga. scripting \u00b6 Comenzaremos esta pr\u00e1ctica creando los scripts y las plantillas que necesitamos para realizar esta parte. 000-default-balancer.conf \u00b6 Este archivo es para nuestro balanceador de carga para que haga el proxy inverso a las m\u00e1quinas frontend, deberemos tener tantos BalancerMember como m\u00e1quinas frontend tengamos. <VirtualHost *:80> <Proxy balancer://cluster-frontend> # Frontend 1 BalancerMember http://IP_HTTP_SERVER_1 # Frontend 2 BalancerMember http://IP_HTTP_SERVER_2 </Proxy> ProxyPass / balancer://cluster-frontend/ </VirtualHost> 000-default-frontend.conf \u00b6 Con este archivo haremos que los equipos frontend busquen en los directorios del sitio web los archivos .htaccess. <VirtualHost *:80> #ServerName www.example.org ServerAdmin webmaster@localhost DocumentRoot /var/www/html #LogLevel info ssl:warm <Directory \"/var/www/html\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost> dir.conf \u00b6 Este archivo nos permite cambiar el orden de prioridades a la hora de servir el contenido de las m\u00e1quinas frontend, le daremos m\u00e1s prioridad al archivo index.php que al archivo index.html <IfModule mod_dir.c> DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm </IfModule> exports \u00b6 Este archivo nos permite establecer en la m\u00e1quina NFS Server el directorio que vamos a compartir, a la red en la que compartiremos el directorio y las opciones para el directorio. /var/www/html 172.31.0.0/16(rw,sync,no_root_squash,no_subtree_check) install_nfs_server.sh \u00b6 Este script nos permitir\u00e1 realizar el despliegue del servidor NFS que tengamos dedicado a almacenamiento y d\u00f3nde estar\u00e1n las p\u00e1ginas web. apt update apt upgrade -y apt install nfs-kernel-server -y mkdir -p /var/www/html chown nobody:nogroup /var/www/html cp ../conf/exports /etc/exports systemctl restart nfs-kernel-server En la m\u00e1quina NFS actualizaremos los repositorios y actualizaremos los programas con respecto a los repositorios descargados, despu\u00e9s instalaremos el servidor NFS (nfs-kernel-server), cuando se realice la descarga e instalaci\u00f3n de NFS Server, crearemos el directorio html usando mkdir y el modificador -p para crear todos los directorios si no est\u00e1n creados. Al directorio creado le cambiaremos tanto el propietario como el grupo para que las m\u00e1quinas puedan montar el directorio creado y acceder a los archivos y directorios que contendr\u00e1n. Despu\u00e9s, copiaremos el archivo exports, que contiene el directorio a compartir, a qu\u00e9 red y las opciones, a la ruta /etc , por \u00faltimo, tendremos que reiniciar el NFS Server. deploy_wordpress.sh \u00b6 Este script como ya lo hemos realizado en la segunda fase, fase-1, lo explicar\u00e9 de forma superficial ya que no tiene cambios con respecto a la anterior fase. source variables.sh wget https://wordpress.org/latest.zip -O /tmp/latest.zip apt install unzip -y rm -rf /var/www/html/wordpress unzip /tmp/latest.zip -d /var/www/html cp /var/www/html/wordpress/wp-config-sample.php /var/www/html/wordpress/wp-config.php sed -i \"s/database_name_here/$DB_Name/\" /var/www/html/wordpress/wp-config.php sed -i \"s/username_here/$DB_User/\" /var/www/html/wordpress/wp-config.php sed -i \"s/password_here/$DB_Password/\" /var/www/html/wordpress/wp-config.php sed -i \"s/localhost/$DB_Host/\" /var/www/html/wordpress/wp-config.php cp /var/www/html/wordpress/index.php /var/www/html sed -i \"s|wp-blog-header.php|wordpress/wp-blog-header.php|\" /var/www/html/index.php sed -i \"/DB_COLLATE/a define('WP_HOME', '$WP_Home');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_HOME/a define('WP_SITEURL', '$WP_SiteURL');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_SITEURL/a \\$_SERVER['HTTPS'] = 'on';\" /var/www/html/wordpress/wp-config.php chown www-data:www-data -R /var/www/html Tenemos que importar el archivo de variables, descargar el c\u00f3digo fuente de WordPress, instalar Unzip y descomprimir los archivos de WordPress en /var/www/html, despu\u00e9s copiar el archivo wp-config-sample.php para renombrar el archivo wp-config.php y modificar su contenido, tambi\u00e9n subiremos un nivel el archivo index.php y modificaremos su contenido y por \u00faltimo, cambiaremos tanto el propietario como el grupo a Apache de todos los archivos que hay en /var/www/html. sed -i \"/WP_SITEURL/a \\$_SERVER['HTTPS'] = 'on';\" /var/www/html/wordpress/wp-config.php Para que nuestra arquitectura funcione correctamente, tenemos que a\u00f1adir a wp-config.php el c\u00f3digo $_SERVER['HTTPS'] = 'on'; ya que como tenemos conexiones HTTP entre el balanceador de carga y los frontales , es posible que nos de problemas el hecho de que se mezclen peticiones HTTP con HTTPS , de forma que con esa l\u00ednea hacemos que \u00fanicamente se realicen mediante HTTPS . Tenemos que usar el backslash o \\ para hacer una secuencia de escape para el s\u00edmbolo \\$ ya que el comando SED coger\u00eda el s\u00edmbolo y su continuaci\u00f3n como una variable . Este script lo ejecutaremos en la m\u00e1quina que tiene el NFS Server . deploy_balancer.sh \u00b6 Necesitaremos que nuestra m\u00e1quina que hace de balanceador de carga tenga un proxy inverso para que las peticiones que reciba las pase a los frontend para que atiendan las peticiones. source variables.sh apt update apt upgrade -y apt install apache2 -y a2enmod proxy a2enmod proxy_http a2enmod proxy_ajp a2enmod rewrite a2enmod deflate a2enmod headers a2enmod proxy_balancer a2enmod proxy_connect a2enmod proxy_html a2enmod lbmethod_byrequests cp ../conf/000-default-balancer.conf /etc/apache2/sites-available/000-default.conf sed -i \"s/IP_HTTP_SERVER_1/$IP_HTTP_Server_1/\" /etc/apache2/sites-available/000-default.conf sed -i \"s/IP_HTTP_SERVER_2/$IP_HTTP_Server_2/\" /etc/apache2/sites-available/000-default.conf systemctl restart apache2 Tenemos que integrar las variables en el script, despu\u00e9s, actualizar los repositorios y los programas con respecto a los repositorios, despu\u00e9s, instalaremos el servidor Apache y habilitaremos los m\u00f3dulos necesarios para realizar el proxy inverso, copiaremos nuestra plantilla a sites-available de Apache, modificaremos el contenido de la plantilla para agregar las direcciones IP de los frontend y reiniciaremos el servidor Apache. install_frontend.sh \u00b6 Es igual al de la anterior fase, lo \u00fanico que cambia es que tenemos una plantilla distinta para permitir el uso de los archivos .htaccess. apt-get update apt-get upgrade -y apt-get install apache2 -y apt-get install php libapache2-mod-php php-mysql -y cp ../conf/000-default-frontend.conf /etc/apache2/sites-available cp ../conf/dir.conf /etc/apache2/mods-available a2enmod rewrite systemctl restart apache2 install_nfs_client.sh \u00b6 Con este script realizaremos el montaje del directorio /var/www/html de la m\u00e1quina NFS Server en los dos frontend para que puedan acceder a los sitios web y agregaremos una l\u00ednea en el archivo /etc/fstab para realizar el montaje del directorio de forma autom\u00e1tica cuando alguna de las m\u00e1quinas frontend se reinicie. source variables.sh apt install nfs-common -y mount $Private_IP_NFS_Server:/var/www/html /var/www/html echo \"$Private_IP_NFS_Server:/var/www/html /var/www/html nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 0 0\" >> /etc/fstab Realizaremos la importaci\u00f3n del archivo de variables e instalaremos el cliente de NFS. Despu\u00e9s, montaremos mediante el comando mount junto a la direcci\u00f3n IP que est\u00e1 en el archivo de variables y la ruta del directorio, /var/www/html, en el directorio /var/www/html de las m\u00e1quinas frontend . Por \u00faltimo, con un echo a\u00f1adiremos la direcci\u00f3n IP de la m\u00e1quina NFS Server junto al directorio que hay que montar y la ruta d\u00f3nde se montar\u00e1, especificaremos que es nfs, auto para que se auto monte al iniciar la m\u00e1quina frontend y varias opciones m\u00e1s mediante una redirecci\u00f3n no destructiva ( >> ) a la ruta /etc/fstab . install_backend.sh \u00b6 Este script tambi\u00e9n lo hemos visto en la fase anterior y nos sirve para instalar el servidor de bases de datos, MySQL. apt-get update apt-get upgrade -y apt-get install mysql-server -y sed -i 's/127.0.0.1/0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf systemctl restart mysql deploy_backend.sh \u00b6 Tambi\u00e9n lo hemos visto en la anterior fase, nos sirve para crear la base de datos junto al usuario y la contrase\u00f1a del usuario, adem\u00e1s de dar privilegios al usuario sobre esa base de datos. source variables.sh echo \"DROP DATABASE IF EXISTS $DB_Name\" | mysql -u root echo \"CREATE DATABASE $DB_Name CHARACTER SET utf8mb4\" | mysql -u root echo \"DROP USER IF EXISTS $DB_User@'%'\" | mysql -u root echo \"CREATE USER $DB_User@'%' IDENTIFIED BY '$DB_Password'\" | mysql -u root echo \"GRANT ALL PRIVILEGES ON $DB_Name.* TO $DB_User@'%'\" | mysql -u root ansible \u00b6 Realizaremos la misma operaci\u00f3n de esta fase, solo que en este caso la realizaremos mediante Ansible. inventario \u00b6 En nuestro archivo de inventario definiremos cuatro grupos, el primero para el balanceador de carga, el segundo para las m\u00e1quinas frontend y que tendr\u00e1n el cliente NFS, el tercer grupo para la m\u00e1quina backend y el cuarto grupo para la m\u00e1quina que tendr\u00e1 el NFS Server. [balancer] 3.233.217.136 [frontend_nfs_client] 18.207.158.92 18.206.16.232 [backend] 100.27.49.133 [nfs_server] 3.237.34.73 [all:vars] ansible_user=ubuntu ansible_ssh_private_key_file=/home/rayseink/claves/vockey.pem ansible_ssh_common_args='-o StrictHostKeyChecking=accept-new' variables.yml \u00b6 Podemos reciclar el anterior archivo de variables ya que tendremos que a\u00f1adir un poco m\u00e1s de contenido y cambiar el contenido de algunas variables. En este archivo vamos a agrupar las variables que se ejecutan en una misma m\u00e1quina. Balancer: Local_Source: ../templates/000-default-balancer.conf.j2 IP_HTTP_Server_1: 172.31.77.79 IP_HTTP_Server_2: 172.31.78.66 Con estas tres siguientes variables establecemos la ruta local del template 000-default-balancer.conf.j2 para el balanceador de carga y las direcciones IP privadas de las m\u00e1quinas frontend para el template. Frontend: Local_Source_000: ../templates/000-default-frontend.conf.j2 DocumentRoot: /var/www/html Local_Source_dir: ../templates/dir.conf.j2 Directory_index: DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm Tambi\u00e9n estableceremos la ruta local del template 000-default-frontend.conf.j2 para los equipos frontend y la variable del DocumentRoot d\u00f3nde se alojan los sitios web para el template.Tambi\u00e9n estableceremos la ruta local del archivo dir.conf.j2 y el contenido del template para priorizar el archivo index.php sobre el index.html. NFS_Server: Local_Source_exports: ../templates/exports.j2 Shared_directory_exports: /var/www/html Range_AWS_Private_IP_exports: 172.31.0.0/16 NFS_Options_exports: rw,sync,no_root_squash,no_subtree_check Private_IP_NFS_Server: 172.31.65.63 Las siguientes variables son la localizaci\u00f3n del template exports.j2 en el equipo local, el directorio del servidor NFS que hay que compartir, el rango de direcciones desde d\u00f3nde tiene que aceptar el servidor NFS peticiones de compartici\u00f3n del directorio compartido, las opciones para el archivo exports y la IP privada de la m\u00e1quina NFS Server. 000-default-balancer.conf.j2 \u00b6 Con este template estableceremos las direcciones IP de las m\u00e1quinas frontend y pasaremos dicho template a la m\u00e1quina que har\u00e1 de balanceador de carga. Deberemos tener tantos BalancerMember como frontend tengamos. <VirtualHost *:80> <Proxy balancer://cluster-frontend> # Frontend 1 BalancerMember http://{{ Balancer.IP_HTTP_Server_1 }} # Frontend 2 BalancerMember http://{{ Balancer.IP_HTTP_Server_2 }} </Proxy> ProxyPass / balancer://cluster-frontend/ </VirtualHost> 000-default-frontend.conf.j2 \u00b6 Usaremos este template para permitir el uso de archivos .htaccess en el directorio /var/www/html de las m\u00e1quinas frontend y leer correctamente el contenido de los sitios web. <VirtualHost *:80> #ServerName www.example.org ServerAdmin webmaster@localhost DocumentRoot {{ Frontend.DocumentRoot }} #LogLevel info ssl:warm <Directory \"{{ Frontend.DocumentRoot }}\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost> exports.j2 \u00b6 Este template nos permite establecer el directorio a compartir en el NFS Server, el rango de direcciones IP que admite para compartir y las opciones que tiene el directorio que vamos a compartir. {{ NFS_Server.Shared_directory_exports }} {{ NFS_Server.Range_AWS_Private_IP_exports }}({{ NFS_Options_exports }}) install_nfs_server.yml \u00b6 Este playbook nos permitir\u00e1 realizar la instalaci\u00f3n del servidor NFS en la m\u00e1quina que hemos definido para este playbook en el archivo inventario y la compartici\u00f3n del directorio que nos interesa, /var/www/html. --- - name: Instalaci\u00f3n de servidor NFS y compartici\u00f3n de directorio hosts: nfs_server become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Actualizaci\u00f3n de los repositorios y de los programas ansible.builtin.apt: update_cache: true only_upgrade: true - name: Instalaci\u00f3n del servidor NFS ansible.builtin.apt: name: nfs-kernel-server state: present Incluiremos el archivo de variables en el playbook, actualizaremos los repositorios y los programas con respecto a los repositorios, despu\u00e9s instalaremos el servidor NFS. - name: Creaci\u00f3n del directorio que hay que compartir ansible.builtin.file: path: /var/www/html state: directory mode: 0755 owner: nobody group: nogroup - name: Copiado de template exports.j2 al equipo remoto ansible.builtin.template: src: \"{{ NFS_Server.Local_Source_exports }}\" dest: /etc/exports mode: 0644 - name: Reinicio del servidor NFS ansible.builtin.service: name: nfs-kernel-server state: restarted Crearemos el directorio html o la ruta completa si no existe y cambiaremos el propietario y el grupo para que las m\u00e1quinas frontend puedan acceder al directorio, despu\u00e9s, pasaremos el template exports.j2 a la m\u00e1quina y le cambiaremos el nombre, por \u00faltimo, reiniciaremos el servidor NFS para aplicar los cambios realizados. deploy_wordpress.yml \u00b6 Este playbook lo ejecutaremos en la m\u00e1quina NFS Server para desplegar WordPress en nuestra arquitectura, es casi id\u00e9ntico al de la fase anterior salvo por hosts . --- - name: Despliegue de WordPress en el servidor NFS hosts: nfs_server become: true - name: Modificaci\u00f3n del archivo wp-config.php para la personalizaci\u00f3n de la URL ansible.builtin.blockinfile: path: /var/www/html/wordpress/wp-config.php insertafter: DB_COLLATE block: | define( 'WP_HOME', '{{ WordPress.Home }}' ); define( 'WP_SITEURL', '{{ WordPress.SiteURL }}' ); $_SERVER['HTTPS'] = 'on'; - name: Borrado del marcado del m\u00f3dulo blockinfile ansible.builtin.lineinfile: path: /var/www/html/wordpress/wp-config.php regexp: ANSIBLE MANAGED BLOCK state: absent Puesto que tenemos que a\u00f1adir tres l\u00edneas, usaremos el m\u00f3dulo blockinfile, es posible que con el m\u00f3dulo nos a\u00f1ada un par de l\u00edneas para indicar el inicio de la inserci\u00f3n de c\u00f3digo y el final , por lo que tenemos que borrar dichas l\u00edneas para que no den problemas , para ello, usaremos el m\u00f3dulo lineinfile, buscaremos con toda la precisi\u00f3n posible las l\u00edneas para borrarlas y marcaremos su state como absent para eliminarlas. deploy_balancer.yml \u00b6 Con este playbook realizaremos el despliegue de nuestro balanceador de carga por software para que pase las peticiones HTTPS que reciba a los frontend mediante HTTP y que estas m\u00e1quinas devuelvan las respuestas al balanceador de carga. Debemos actualizar los repositorios y los programas instalados con respecto a los repositorios descargados, instalar el servidor Apache y habilitar varios m\u00f3dulos para realizar el proxy inverso. - name: Copiado de template 000-default-balancer.conf.j2 al equipo remoto ansible.builtin.template: src: \"{{ Balancer.Local_Source }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 notify: Reinicio de servidor Apache handlers: - name: Reinicio de servidor Apache ansible.builtin.service: name: apache2 state: restarted Por \u00faltimo, pasaremos nuestro template 000-default-balancer.conf.j2 al equipo remoto y reiniciaremos el servidor Apache. install_frontend.yml \u00b6 Realizaremos la instalaci\u00f3n de Apache, PHP y los m\u00f3dulos de PHP para conectar con Apache y MySQL en las m\u00e1quinas frontend. Tambi\u00e9n tenemos que pasar dos templates, uno para establecer el DocumentRoot a la ruta /var/www/html y el otro para establecer prioridades con respecto a los archivos index. --- - name: Instalaci\u00f3n de Apache y habilitaci\u00f3n de m\u00f3dulo para Apache en los equipos frontend hosts: frontend_nfs_client become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Copiado de template 000-default-frontend.conf.j2 a los equipos remotos ansible.builtin.template: src: \"{{ Frontend.Local_Source_000 }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 - name: Copiado de template dir.conf.j2 a los equipos remotos ansible.builtin.template: src: \"{{ Frontend.Local_Source_dir }}\" dest: /etc/apache2/mods-available/dir.conf mode: 0644 Esta es una parte del archivo YAML, tenemos que establecer el grupo de m\u00e1quinas sobre las que ejecutar el playbook e incluir nuestro archivo de variables, con el primer template establecemos el DocumentRoot que por defecto servir\u00e1n los frontend y con el segundo establecemos la prioridad del index.php sobre el index.html. install_nfs_client.yml \u00b6 Este playbook es para instalar el cliente NFS en las m\u00e1quinas frontend y poder montar el directorio /var/www/html de la m\u00e1quina NFS Server en el directorio local /var/www/html de las m\u00e1quinas y poder servir el mismo contenido teniendo varias m\u00e1quinas frontend. --- - name: Instalaci\u00f3n de cliente NFS para conectar con el servidor NFS hosts: frontend_nfs_client become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n de NFS cliente ansible.builtin.apt: name: nfs-common state: present - name: Montado del directorio compartido del servidor NFS en los clientes ansible.posix.mount: path: /var/www/html src: \"{{ NFS_Server.Private_IP_NFS_Server }}:/var/www/html\" fstype: nfs state: mounted opts: auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 Tenemos que establecer el grupo sobre el que ejecutar este playbook, las m\u00e1quinas frontend, incluir el archivo de variables y realizar la instalaci\u00f3n del cliente NFS, por \u00faltimo, con el FQCN ansible.posix.mount realizaremos el montado del directorio de la m\u00e1quina NFS Server mediante su direcci\u00f3n IP y la ruta del directorio compartido, tambi\u00e9n estableceremos el tipo de file system (fstype), el state mount para que se monte y se configure el archivo /etc/fstab para a\u00f1adir la direcci\u00f3n IP y la ruta junto a fstype y opts. main.yml \u00b6 Estableceremos el orden de ejecuci\u00f3n de los playbooks en nuestro archivo principal. --- - name: Ejecuci\u00f3n del playbook de instalaci\u00f3n del servidor NFS ansible.builtin.import_playbook: playbooks/install_nfs_server.yml - name: Ejecuci\u00f3n del playbook de despliegue de WordPress en el servidor NFS ansible.builtin.import_playbook: playbooks/deploy_wordpress.yml - name: Ejecuci\u00f3n del playbook de despliegue del balanceador de carga ansible.builtin.import_playbook: playbooks/deploy_balancer.yml - name: Ejecuci\u00f3n del playbook de obtenci\u00f3n del certificado de Let's Encrypt ansible.builtin.import_playbook: playbooks/https.yml when: certificado | d(False) == \"descargar\" - name: Ejecuci\u00f3n del playbook de preparaci\u00f3n de los equipos frontend ansible.builtin.import_playbook: playbooks/install_frontend.yml - name: Ejecuci\u00f3n del playbook de instalaci\u00f3n de cliente NFS y conexi\u00f3n con el servidor ansible.builtin.import_playbook: playbooks/install_nfs_client.yml - name: Ejecuci\u00f3n del playbook de preparaci\u00f3n del equipo backend ansible.builtin.import_playbook: playbooks/install_backend.yml - name: Ejecuci\u00f3n del playbook de creaci\u00f3n de la base de datos con usuario y contrase\u00f1a ansible.builtin.import_playbook: playbooks/deploy_backend.yml Debemos tener un orden de ejecuci\u00f3n correcto ya que de no ser as\u00ed, podr\u00eda no funcionar. Primero ejecutaremos la instalaci\u00f3n del servidor NFS e inmediatamente despu\u00e9s el despliegue de WordPress en la m\u00e1quina NFS Server. A continuaci\u00f3n, realizaremos el despliegue del balanceador de carga y despu\u00e9s la obtenci\u00f3n del certificado de Let's Encrypt en el balanceador de carga. Despu\u00e9s, realizaremos la preparaci\u00f3n de los equipos frontend para instalar tanto Apache como PHP y los m\u00f3dulos de PHP para conectar con MySQL y Apache, tambi\u00e9n realizaremos la instalaci\u00f3n del cliente NFS en los equipos frontend y el montaje de la unidad de red del equipo NFS Server. Por \u00faltimo, prepararemos el equipo backend y crearemos la base de datos. El orden establecido en main.yml puede ser un poco aleatorio, aunque s\u00ed que es necesario que un playbook concreto se ejecute antes de otro playbook para realizar correctamente la fase , en este caso, tenemos que preparar la m\u00e1quina NFS Server y compartir el directorio antes de que en los equipos frontend se instale el cliente NFS y se haga el montado del directorio , ya que de ser al contrario dar\u00eda fallos. Tambi\u00e9n debemos tener en cuenta que antes de descargar el certificado de Let's Encrypt en el balanceador de carga, debemos tener instalado el servidor Apache . Comprobaci\u00f3n del despliegue de WordPress en tres niveles \u00b6 Seguiremos un orden concreto y correcto para esta pr\u00e1ctica en cuanto a la ejecuci\u00f3n de los scripts y el orden establecido anteriormente de ejecuci\u00f3n de los playbooks de Ansible. Debemos tener en cuenta que si queremos ejecutar los scripts, debemos clonar el repositorio en todas las m\u00e1quinas. Mediante scripts en la m\u00e1quina NFS Server debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./install_nfs_server.sh sudo ./deploy_wordpress.sh Con este orden preparemos primero la m\u00e1quina NFS Server para realizar la compartici\u00f3n del directorio /var/www/html y de los archivos de WordPress en las m\u00e1quinas frontend tras realizar el despliegue de WordPress en la m\u00e1quina. Mediante scripts en la m\u00e1quina balanceador de carga debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./deploy_balancer.sh sudo ./https_balancer.sh Con este orden hacemos que el balanceador de carga instale Apache y realice la configuraci\u00f3n necesaria para actuar como proxy inverso con los frontales, una vez se haga el despliegue del balanceador, se obtendr\u00e1 el certificado de Let's Encrypt y dispondremos de HTTPS en las peticiones entrantes al balanceador. Mediante scripts en las m\u00e1quinas frontend debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./install_frontend.sh sudo ./install_nfs_client.sh Con este orden instalamos Apache, PHP, los m\u00f3dulos de PHP necesarios para conectar con MySQL y Apache, tambi\u00e9n preparamos el directorio /var/www/html para conectar con la unidad de red del servidor NFS. Mediante scripts en la m\u00e1quina backend debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./install_backend.sh sudo ./deploy_backend.sh Tal y como hicimos en la anterior fase, podemos saltar en este caso la ejecuci\u00f3n completa del playbook https.yml mediante el Statement When , por lo que para nuestra primera ejecuci\u00f3n tendremos que usar el comando: ansible-playbook -i inventario main.yml --extra-vars \"certificado=descargar\" Cuando hayamos realizado la ejecuci\u00f3n mediante scripts o Ansible, accederemos mediante la direcci\u00f3n IP o el nombre de dominio que hemos puesto en No-IP. Escogeremos el idioma que queremos y continuaremos. Podremos los datos del sitio y pulsaremos en Instalar WordPress. Cuando hayamos realizado la instalaci\u00f3n de WordPress, accederemos mediante el dominio que hemos asignado para comprobar que nuestro certificado en el balanceador de carga funciona correctamente. Accederemos al BackOffice de WordPress para comprobar que funciona correctamente, en la URL tenemos que poner: https://nombre-dominio/wp-login.php \u00d3 https://nombre-dominio/wordpress/wp-login.php De cualquiera de las formas nos sirven ya que con la primera usamos la redirecci\u00f3n que hemos establecido en wp-config.php y con la segunda forma hacemos referencia al directorio y al archivo de acceso, ponemos los datos de acceso que hemos establecido durante la instalaci\u00f3n en el navegador web y veremos que podemos acceder sin problemas. Mediante SSH accederemos a una de las m\u00e1quinas frontend y usaremos el comando cat /etc/fstab para comprobar que se ha modificado correctamente el archivo con la direcci\u00f3n IP privada del servidor NFS y el directorio compartido, el fstype y las options configuradas para los clientes.","title":"Arquitectura WordPress"},{"location":"arquitectura-wordpress/#practica-9-de-iaw-instalacion-de-wordpress-en-distintos-niveles","text":"Esta pr\u00e1ctica la realizaremos por fases, en la primera fase, fase-0, realizaremos la instalaci\u00f3n de WordPress en un \u00fanico nodo o instancia, en la segunda fase, fase-1, realizaremos la misma instalaci\u00f3n en dos niveles, un frontend (servidor web Apache2) y un backend (servidor SQL), por \u00faltimo, en la tercera fase, fase-2, realizaremos la instalaci\u00f3n de un balanceador de carga, dos frontend, un backend y un servidor NFS para almacenar datos compartidos para los dos frontend. Los requisitos para las tres fases con una instancia Ubuntu Server 22.04 o Ubuntu Server 20.04 con al menos 2GB de RAM . Tendremos en cuenta los puertos de entrada en cada m\u00e1quina que tendremos que abrir: Nodo \u00fanico --> HTTPS (puerto 443), HTTP (puerto 80) y SSH (puerto 22) Frontend sin balanceador de carga --> HTTPS (puerto 443), HTTP (puerto 80) y SSH (puerto 22) Frontend con balanceador de carga --> HTTP (puerto 80) y SSH (puerto 22) Backend --> MySQL/Aurora (puerto 3306) y SSH (puerto 22) Balanceador de carga --> HTTPS (puerto 443), HTTP (puerto 80) y SSH (puerto 22) NFS Server --> NFS (puerto 2049) y SSH (puerto 22) Prepararemos la siguiente estructura de directorios y archivos: fase-0 ansible playbooks deploy_wordpress.yml https.yml install_lamp.yml templates 000-default.conf.j2 dir.conf.j2 vars variables.yml inventario --> Archivo main.yml scripting conf 000-default.conf dir.conf scripts config-https.sh deploy_wordpress.sh install_lamp.sh variables.sh fase-1 ansible playbooks deploy_backend.yml deploy_wordpress.yml https.yml install_backend.yml install_frontend.yml templates 000-default.conf.j2 dir.conf.j2 vars variables.yml inventario --> Archivo main.yml scripting conf 000-default.conf dir.conf scripts deploy_backend.sh deploy_wordpress.sh https_frontend.sh install_backend.sh install_frontend.sh variables.sh fase-2 ansible playbooks deploy_backend.yml deploy_balancer.yml deploy_wordpress.yml https.yml install_backend.yml install_frontend.yml install_nfs_client.yml install_nfs_server.yml templates 000-default-balancer.conf.j2 000-default-frontend.conf.j2 dir.conf.j2 exports.j2 vars variables.yml inventario --> Archivo main.yml scripting conf 000-default-balancer.conf 000-default-frontend.conf dir.conf exports scripts deploy_backend.sh deploy_balancer.sh deploy_wordpress.sh https_balancer.sh install_backend.sh install_frontend.sh install_nfs_client.sh install_nfs_server.sh variables.sh Crearemos un repositorio para la pr\u00e1ctica. Warning Las im\u00e1genes pueden que funcionen o no","title":"Pr\u00e1ctica 9 de IAW - Instalaci\u00f3n de WordPress en distintos niveles"},{"location":"arquitectura-wordpress/#fase-0","text":"Iniciaremos esta pr\u00e1ctica explicando la primera fase, mediante scripting como con ansible. Crearemos en No-IP un dominio asignado a una direcci\u00f3n IP.","title":"fase-0"},{"location":"arquitectura-wordpress/#scripting","text":"Una vez tengamos la estructura de directorios y archivos necesarios, empezaremos con los archivos que tenemos que nos sirven de plantillas para usar una configuraci\u00f3n concreta en la instancia.","title":"scripting"},{"location":"arquitectura-wordpress/#000-defaultconf","text":"Este archivo lo necesitaremos para permitir la creaci\u00f3n de archivos htaccess mediante AllowOverride All y permitir que el sitio web funcione correctamente. <VirtualHost *:80> ServerAdmin webmaster@localhost DocumentRoot /var/www/html #LogLevel info ssl:warm <Directory \"/var/www/html\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost>","title":"000-default.conf"},{"location":"arquitectura-wordpress/#dirconf","text":"Con este archivo priorizaremos el archivo index.php sobre el resto de los archivos. <IfModule mod_dir.c> DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm </IfModule>","title":"dir.conf"},{"location":"arquitectura-wordpress/#variablessh","text":"Este archivo nos permitir\u00e1 tener variables globales para los scripts que las necesiten y no tener que cambiar el contenido de las variables en varios archivos. DB_Name=wp_db DB_User=wp_user DB_Password=wp_pass DB_Host=localhost WP_Home=https://practicasiaw09jrrl.ddns.net WP_SiteURL=https://practicasiaw09jrrl.ddns.net/wordpress Certbot_Email=tetz_dqhwr17@yutep.com Certbot_Domain=practicasiaw09jrrl.ddns.net Las tres primeras l\u00edneas nos permiten establecer la base de datos con el usuario y la contrase\u00f1a para ese usuario, la cuarta nos permite indicar d\u00f3nde se encuentra la base de datos, en nuestro caso como est\u00e1 en la misma m\u00e1quina ser\u00e1 localhost. La cuarta variable nos permite indicar el formato de la URL que queremos para nuestro sitio web , la quinta variable establece la ruta local d\u00f3nde se encuentra la instalaci\u00f3n de WordPress , las dos \u00faltimas variables son para la obtenci\u00f3n del certificado de Let's Encrypt usando Certbot.","title":"variables.sh"},{"location":"arquitectura-wordpress/#install_lampsh","text":"Instalaremos la pila LAMP en nuestra instancia, tambi\u00e9n copiaremos las dos plantillas a su respectiva ruta, habilitaremos el m\u00f3dulo rewrite para que WordPress pueda hacer cambios y reiniciaremos el servidor Apache2 para aplicar los cambios realizados. apt-get update apt-get upgrade -y apt-get install apache2 -y apt-get install mysql-server -y apt-get install php libapache2-mod-php php-mysql -y Como de costumbre, seguiremos los mismos pasos para la instalaci\u00f3n de la pila LAMP. cp ../conf/000-default.conf /etc/apache2/sites-available cp ../conf/dir.conf /etc/apache2/mods-available a2enmod rewrite systemctl restart apache2 A continuaci\u00f3n, copiaremos la primera plantilla , 000-default.conf a la ruta /etc/apache2/sites-available para permitir el uso de archivos .htaccess y que nuestro sitio web funcione correctamente en cuanto al contenido servido. Copiaremos la segunda plantilla , dir.conf a la ruta /etc/apache2/mods-available para priorizar los archivos index seg\u00fan formato, luego habilitaremos el m\u00f3dulo rewrite de Apache y reiniciaremos el servidor web.","title":"install_lamp.sh"},{"location":"arquitectura-wordpress/#config-httpssh","text":"Este segundo script nos permitir\u00e1 la configuraci\u00f3n del servidor para usar el protocolo HTTPS, tendremos que instalar Certbot mediante Snap y obtener el certificado de Let's Encrypt. Este script lo hemos realizado en pr\u00e1cticas anteriores, por lo que realizar\u00e9 una explicaci\u00f3n superficial del script source variables.sh snap install core snap refresh core apt-get remove Certbot snap install --classic Certbot ln -s /snap/bin/certbot /usr/bin/certbot certbot --apache -m $Certbot_Email --agree-tos --no-eff-email -d $Certbot_Domain Importaremos el archivo de variables e instalaremos Core mediante Snap, despu\u00e9s actualizaremos Core y quitaremos la instalaci\u00f3n por defecto de Certbot que viene con el sistema operativo, despu\u00e9s instalaremos Certbot mediante Snap y solicitaremos el certificado de Let's Encrypt.","title":"config-https.sh"},{"location":"arquitectura-wordpress/#deploy_wordpresssh","text":"Con este script realizaremos el despliegue de WordPress en la instancia, necesitaremos descargar el c\u00f3digo fuente de WordPress, as\u00ed como Unzip, crear una base de datos, descomprimir los archivos en /var/www/html y personalizar WordPress. source variables.sh wget https://wordpress.org/latest.zip -O /tmp/latest.zip apt install unzip -y unzip /tmp/latest.zip -d /var/www/html cp /var/www/html/wordpress/wp-config-sample.php /var/www/html/wordpress/wp-config.php sed -i \"s/database_name_here/$DB_Name/\" /var/www/html/wordpress/wp-config.php sed -i \"s/username_here/$DB_User/\" /var/www/html/wordpress/wp-config.php sed -i \"s/password_here/$DB_Password/\" /var/www/html/wordpress/wp-config.php sed -i \"s/localhost/$DB_Host/\" /var/www/html/wordpress/wp-config.php En esta parte del script realizaremos la importaci\u00f3n de las variables definidas, despu\u00e9s descargaremos el c\u00f3digo fuente de WordPress, instalaremos Unzip y descomprimiremos el contenido en /var/www/html, de forma que en la ruta deberemos tener tanto index.html como un directorio llamado wordpress . A continuaci\u00f3n, copiaremos el archivo wp-config-sample.php en la misma ruta con distinto nombre para realizar modificaciones sobre la copia, wp-config.php . Las modificaciones que deberemos hacer son la asignaci\u00f3n de la base de datos, el usuario y su contrase\u00f1a y la localizaci\u00f3n de la base de datos. echo \"DROP DATABASE IF EXISTS $DB_Name\" | mysql -u root echo \"CREATE DATABASE $DB_Name CHARACTER SET utf8mb4\" | mysql -u root echo \"DROP USER IF EXISTS $DB_User@'%'\" | mysql -u root echo \"CREATE USER $DB_User@'%' IDENTIFIED BY '$DB_Password'\" | mysql -u root echo \"GRANT ALL PRIVILEGES ON $DB_Name.* TO $DB_User@'%'\" | mysql -u root cp /var/www/html/wordpress/index.php /var/www/html sed -i \"s|wp-blog-header.php|wordpress/wp-blog-header.php|\" /var/www/html/index.php sed -i \"/DB_COLLATE/a define('WP_HOME', '$WP_Home');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_HOME/a define('WP_SITEURL', '$WP_SiteURL');\" /var/www/html/wordpress/wp-config.php chown www-data:www-data -R /var/www/html Despu\u00e9s, crearemos la base de datos junto al usuario y su contrase\u00f1a y copiaremos el archivo index.php para ponerlo en un nivel superior , en /var/www/html para que en cuanto se acceda al dominio o a la direcci\u00f3n IP del servidor se acceda directamente sin tener que referenciar el directorio de instalaci\u00f3n de WordPress en el equipo . Por \u00faltimo, modificaremos el index.php para hacer referencia a la localizaci\u00f3n del archivo wp-blog-header.php y que nuestro WordPress funcione correctamente. Tambi\u00e9n modificaremos el contenido del archivo wp-config.php para a\u00f1adir un par de l\u00edneas que indicar\u00e1n el formato de URL que tendr\u00e1 el sitio y la ruta interna a los archivos de WordPress , adem\u00e1s de cambiar el propietario y el grupo de html de forma recursiva.","title":"deploy_wordpress.sh"},{"location":"arquitectura-wordpress/#ansible","text":"Realizaremos la misma parte mediante ansible, de forma que modificaremos lo realizado mediante scripting para ajustarlo al uso de Ansible.","title":"ansible"},{"location":"arquitectura-wordpress/#variablesyml","text":"En este archivo tendremos las variables para usarlas en los playbooks que las necesiten. Certbot: Email: tetz_dqhwr17@yutep.com Domain: practicasiaw09jrrl.ddns.net Template_000_default: Local_Source: ../templates/000-default.conf.j2 DocumentRoot: /var/www/html Template_dir: Local_Source: ../templates/dir.conf.j2 Directory_index: DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm PHP_Packages: - php - libapache2-mod-php - php-mysql Database: Name: wordpress_db User: wordpress_user Password: wordpress_pass Host: localhost WordPress: Home: http://practicasiaw09jrrl.ddns.net SiteURL: http://practicasiaw09jrrl.ddns.net/wordpress Introduciremos las variables que necesitamos dentro de otra variable que ser\u00e1 la global para tenerlas agrupadas por funci\u00f3n o m\u00e1quina d\u00f3nde se ejecutar\u00e1n. De esta forma evitamos tener variables sueltas y evitamos el caos resultante. Las dos primeras variables nos servir\u00e1n para la obtenci\u00f3n del certificado de Let's Encrypt y poder usar HTTPS, la tercera indica la ruta local del template 000-default.conf.j2 y la cuarta el contenido de la variable de dicho template. La quinta indica la ruta local del template dir.conf.j2 y la sexta el contenido de la variable de dicho template, en la s\u00e9ptima variable indicamos los paquetes de PHP que hay que instalar. Las siguientes cuatro variables son para indicar la base de datos, el usuario y su contrase\u00f1a y la localizaci\u00f3n de la base de datos. Las dos \u00fa ltimas son para la personalizaci\u00f3n de la URL de WordPress y la ruta interna de los archivos de WordPress en el equipo.","title":"variables.yml"},{"location":"arquitectura-wordpress/#000-defaultconfj2","text":"Al igual que hicimos con los scripts, crearemos una plantilla o template para copiar el template en el equipo local al equipo remoto y haremos unas modificaciones mediante variables, que en este caso, tenemos que hacer referencia a la variable global seguido de un punto (o dot) seguido de la variable que tiene el contenido que necesitamos . <VirtualHost *:80> #ServerName www.example.org ServerAdmin webmaster@localhost DocumentRoot {{ Template_000_default.DocumentRoot }} #LogLevel info ssl:warm <Directory \"{{ Template_000_default.DocumentRoot }}\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost> El contenido del template es lo mismo, salvo que usaremos una variable para definir el directorio de localizaci\u00f3n de WordPress y si fuese necesario podr\u00edamos modificar el contenido de la variable sin tener que modificar el template.","title":"000-default.conf.j2"},{"location":"arquitectura-wordpress/#dirconfj2","text":"Al igual que con el scripting, priorizaremos las extensiones de los archivos index para que primero se nos muestre primero el index.php sobre el index.html. <IfModule mod_dir.c> {{ Template_dir.Directory_index }} </IfModule>","title":"dir.conf.j2"},{"location":"arquitectura-wordpress/#inventario","text":"Definiremos los par\u00e1metros globales para el usuario de la instancia, la localizaci\u00f3n de la clave privada de la instancia en el equipo local y que no nos pregunte si queremos a\u00f1adir el fingerprint o huella de la m\u00e1quina. Tambi\u00e9n especificaremos el grupo wordpress y la direcci\u00f3n IP que tiene la instancia en el momento de crearla o la direcci\u00f3n IP el\u00e1stica si asignamos una a la instancia. [wordpress] 18.204.227.200 [wordpress:vars] ansible_user=ubuntu ansible_ssh_private_key_file=/home/rayseink/claves/vockey.pem ansible_ssh_common_args='-o StrictHostKeyChecking=accept-new'","title":"inventario"},{"location":"arquitectura-wordpress/#install_lampyml","text":"Realizaremos la instalaci\u00f3n de la pila LAMP y pasaremos los templates al equipo remoto, habilitaremos el m\u00f3dulo rewrite y reiniciaremos el servidor Apache2. --- - name: Playbook para el despliegue de la pila LAMP hosts: wordpress become: true tasks: - name: Inclusi\u00f3n de variables para los templates ansible.builtin.include_vars: ../vars/variables.yml - name: Actualizaci\u00f3n de los repositorios ansible.builtin.apt: update_cache: true upgrade: true - name: Instalaci\u00f3n del servidor web Apache2 ansible.builtin.apt: name: apache2 state: present - name: Instalaci\u00f3n del servidor de bases de datos ansible.builtin.apt: name: mysql-server state: present - name: Instalaci\u00f3n de PHP y m\u00f3dulos para conectar con la base de datos y Apache2 ansible.builtin.apt: name: \"{{ PHP_Packages }}\" state: present Hasta aqu\u00ed es la inclusi\u00f3n del archivo de variables en el playbook para los dos templates que vamos a pasar al servidor, la actualizaci\u00f3n de los repositorios y los programas con respecto a los repositorios, la instalaci\u00f3n de Apache2, MySQL Server y los paquetes de PHP. - name: Copiado del template 000-default.conf.j2 a la ruta /etc/apache2/sites-available ansible.builtin.template: src: \"{{ Template_000_default.Local_Source }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 - name: Copiado del template dir.conf.j2 a la ruta /etc/apache2/mods-available ansible.builtin.template: src: \"{{ Template_dir.Local_Source }}\" dest: /etc/apache2/mods-available/dir.conf mode: 0644 - name: Habilitaci\u00f3n del m\u00f3dulo rewrite de Apache2 community.general.apache2_module: name: rewrite state: present notify: Reiniciar servidor Apache2 handlers: - name: Reiniciar servidor Apache2 ansible.builtin.service: name: apache2 state: restarted Usaremos el m\u00f3dulo ansible.builtin.template para pasar los templates locales al servidor y habilitaremos el m\u00f3dulo rewrite de Apache2 para que WordPress pueda realizar cambios en el servidor web, por \u00faltimo reiniciaremos Apache2 para que se apliquen los cambios.","title":"install_lamp.yml"},{"location":"arquitectura-wordpress/#httpsyml","text":"Con este playbook realizaremos la descarga de Certbot y la obtenci\u00f3n del certificado de Let's Encrypt para poder usar HTTPS en nuestro servidor. --- - name: Descarga de Certbot mediante Snap y obtenci\u00f3n de certificado de Let's Encrypt hosts: wordpress become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Desinstalaci\u00f3n de la instalaci\u00f3n previa de Certbot que viene con el sistema operativo ansible.builtin.apt: name: certbot state: absent - name: Instalaci\u00f3n de Certbot mediante Snap community.general.snap: name: certbot classic: true state: present - name: Descarga de certificado para TLS / SSL ansible.builtin.command: certbot --apache -m \"{{ Certbot_Email }}\" --agree-tos --no-eff-email -d \"{{ Certbot_Domain }}\" register: realizar_cambio changed_when: realizar_cambio.rc == 0 Incluiremos el archivo de variables en el playbook y desinstalaremos Certbot que viene con el sistema operativo, despu\u00e9s instalaremos mediante Snap la versi\u00f3n correcta de Certbot y obtendremos el certificado de Let's Encrypt.","title":"https.yml"},{"location":"arquitectura-wordpress/#deploy_wordpressyml","text":"Realizaremos el despliegue de WordPress en el equipo remoto, crearemos una base de datos con un usuario y una contrase\u00f1a y haremos las modificaciones pertinentes para WordPress. --- - name: Despliegue de WordPress en un \u00fanico nodo hosts: wordpress become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n de Unzip para descomprimir archivos ansible.builtin.apt: name: unzip state: present - name: Descarga del c\u00f3digo fuente de WordPress en directorio temporal ansible.builtin.get_url: url: https://wordpress.org/latest.zip dest: /tmp/wordpress.zip mode: 664 - name: Descompresi\u00f3n de WordPress en /var/www/html ansible.builtin.unarchive: src: /tmp/wordpress.zip dest: /var/www/html remote_src: true - name: Borrado del archivo comprimido en el directorio temporal ansible.builtin.file: path: /tmp/wordpress.zip state: absent - name: Copiado de archivo wp-config-sample.php a wp-config.php ansible.builtin.copy: src: /var/www/html/wordpress/wp-config-sample.php dest: /var/www/html/wordpress/wp-config.php mode: 0644 remote_src: true Empezaremos incluyendo el archivo de variables en el playbook, despu\u00e9s instalaremos Unzip para la descompresi\u00f3n de archivos, descargaremos el c\u00f3digo fuente de WordPress en el directorio temporal, descomprimiremos el archivo de WordPress en /var/www/html, borraremos el archivo comprimido que contiene WordPress y copiaremos el archivo wp-config-sample.php en la misma ruta para modificar el nombre del archivo a wp-config.php usando el m\u00f3dulo ansible.builtin.copy y con la opci\u00f3n remote_src: true para indicar que es en el equipo remoto . - name: Modificaci\u00f3n del archivo wp-config.php para especificar la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: database_name_here replace: \"{{ Database.Name }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el usuario de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: username_here replace: \"{{ Database.User }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar la contrase\u00f1a del usuario ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: password_here replace: \"{{ Database.Password }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el servidor de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: localhost replace: \"{{ Database.Host }}\" Modificaremos el archivo wp-config.php para indicar la base de datos, el usuario de la base de datos y su contrase\u00f1a, adem\u00e1s de la conexi\u00f3n a la base de datos, que en este caso es localhost. - name: Instalaci\u00f3n del gestor de paquetes de Python3 ansible.builtin.apt: name: python3-pip state: present - name: Instalaci\u00f3n del m\u00f3dulo PyMySQL mediante el gestor de paquetes de Python3 para conectar conectar con el socket ansible.builtin.pip: name: pymysql state: present - name: Creaci\u00f3n de la base de datos usando el socket de PyMySQL community.mysql.mysql_db: name: \"{{ Database.Name }}\" state: present login_unix_socket: /run/mysqld/mysqld.sock - name: Creaci\u00f3n del usuario con la contrase\u00f1a para la base de datos no_log: true community.mysql.mysql_user: name: \"{{ Database.User }}\" host: '%' password: \"{{ Database.Password }}\" priv: \"{{ Database.Name }}.*:ALL\" state: present login_unix_socket: /run/mysqld/mysqld.sock A continuaci\u00f3n, crearemos la base de datos con el usuario y la contrase\u00f1a, para ello, necesitamos instalar en el equipo remoto el gestor de paquetes de Python3 y el m\u00f3dulo PyMySQL . Para la base de datos con el usuario y contrase\u00f1a necesitaremos usar el socket de MySQL (mysqld.sock) que se encuentra en /run/mysqld para poder realizar las operaciones pertinentes usando el m\u00f3dulo PyMySQL . - name: Copiado del archivo index.php de html/wordpress a html ansible.builtin.copy: src: /var/www/html/wordpress/index.php dest: /var/www/html/index.php mode: 0644 remote_src: true - name: Modificaci\u00f3n del archivo index.php para la redirecci\u00f3n a WordPress ansible.builtin.replace: path: /var/www/html/index.php regexp: wp-blog-header.php replace: wordpress/wp-blog-header.php - name: Modificaci\u00f3n del archivo wp-config.php para la personalizaci\u00f3n de la URL ansible.builtin.blockinfile: path: /var/www/html/wordpress/wp-config.php insertafter: DB_COLLATE block: | define('WP_HOME', '{{ WordPress.Home }}'); define('WP_SITEURL', '{{ WordPress.SiteURL }}'); - name: Cambio de propietario y grupo para /var/www/html ansible.builtin.file: path: /var/www/html owner: www-data group: www-data recurse: true notify: Reinicio de Apache2 handlers: - name: Reinicio de Apache2 ansible.builtin.service: name: apache2 state: restarted Para finalizar con el playbook, subiremos un nivel el archivo index.php que se encuentra en /var/www/html/wordpress y lo modificaremos para indicar la ruta al archivo wp-blog-header.php que se encuentra en el directorio wordpress . Tambi\u00e9n modificaremos el archivo wp-config.php para personalizar la URL de WordPress y evitar que aparezca el directorio d\u00f3nde se ubica, usaremos el m\u00f3dulo ansible.builtin.blockinfile , indicaremos la ruta del archivo y que vamos a a\u00f1adir un bloque de c\u00f3digo despu\u00e9s de la l\u00ednea que contenga DB_COLLATE con insertafter y con block las l\u00edneas que queremos a\u00f1adir , la primera para indicar el formato de la URL y la segunda la ubicaci\u00f3n interna de WordPress. A continuaci\u00f3n, cambiaremos el propietario y el grupo de la ruta /var/www/html de forma recursiva y provocaremos el reinicio de Apache2 mediante notify y el handler correspondiente.","title":"deploy_wordpress.yml"},{"location":"arquitectura-wordpress/#mainyml","text":"Este archivo ser\u00e1 el que importar\u00e1 los playbooks y el que ejecutemos para realizar la instalaci\u00f3n de la pila LAMP, la configuraci\u00f3n para HTTPS y el despliegue de WordPress. Usaremos tags para cada importaci\u00f3n de playbook ya que si queremos evitar que un playbook o playbooks se ejecuten tenemos que hacer referencia al tag o tags que no queremos que se ejecuten , como por ejemplo el playbook https, tambi\u00e9n podemos hacer el caso contrario de ejecutar un playbook o playbooks mediante el tag o tags , los tags tambi\u00e9n nos permiten referenciar cada task o playbook para su identificaci\u00f3n. --- - name: Importaci\u00f3n de playbook para instalar la pila LAMP ansible.builtin.import_playbook: playbooks/install_lamp.yml tags: lamp - name: Importaci\u00f3n de playbook para preparar HTTPS import_playbook: playbooks/https.yml tags: certificado - name: Importaci\u00f3n de playbook para el despliegue de wordpress ansible.builtin.import_playbook: playbooks/deploy_wordpress.yml tags: wordpress El orden de ejecuci\u00f3n es primero pila LAMP, despu\u00e9s la obtenci\u00f3n del certificado de Let's Encrypt ya que para este playbook necesitamos tener instalado Apache y por \u00faltimo el despliegue de WordPress.","title":"main.yml"},{"location":"arquitectura-wordpress/#comprobacion-del-despliegue-de-wordpress-en-un-nivel","text":"Como tenemos dos formas de realizar esta fase, escogeremos la que queramos, podemos hacerlo mediante scripting que deberemos clonar el repositorio en el que hemos realizado los scripts al equipo en el que instalaremos WordPress o con ansible desde nuestro equipo local lanzando el archivo main.yml. Debemos tener en cuenta el orden de ejecuci\u00f3n de los scripts y de los playbooks , por ejemplo, para obtener el certificado de Let's Encrypt, necesitamos que la m\u00e1quina tenga instalado el servidor Apache . Mediante scripting tenemos que ejecutar los scripts en el siguiente orden y en la ruta d\u00f3nde se encuentran : sudo ./install_lamp.sh sudo ./config-https.sh sudo ./deploy_wordpress.sh Mediante ansible en la ruta d\u00f3nde se encuentra el archivo inventario y main.yml : ansible-playbook -i inventario main.yml De la forma anterior con Ansible ejecutamos todos los playbooks y en el caso de que queramos saltar un playbook, como por ejemplo la instalaci\u00f3n de Certbot mediante Snap y la descarga del certificado de Let's Encrypt, usaremos: ansible-playbook -i inventario main.yml --skip-tags certificado Para el caso contrario, s\u00f3lo tenemos que ejecutar: ansible-playbook -i inventario main.yml --tags [lamp, wordpress] Una vez lancemos la instalaci\u00f3n de una forma u otra, cuando termine la ejecuci\u00f3n, accederemos a trav\u00e9s de un navegador web a la direcci\u00f3n IP de la instancia o mediante el dominio que hemos asignado. Nos saldr\u00e1 el idioma que queremos para nuestro WordPress, lo escogemos y pasamos al siguiente paso. Cuando terminemos de poner los datos que nos piden, pulsaremos en el bot\u00f3n Instalar WordPress. Cuando hayamos accedido al backoffice, usaremos el dominio en una pesta\u00f1a nueva para comprobar que funciona correctamente.","title":"Comprobaci\u00f3n del despliegue de WordPress en un nivel"},{"location":"arquitectura-wordpress/#fase-1","text":"Para esta fase necesitaremos dos equipos, un frontend y un backend, en este caso como no necesitamos balanceador de carga, por lo que tendremos que abrir los puertos de HTTPS, HTTP y SSH en la m\u00e1quina frontend. Crearemos un nuevo dominio y asignaremos la direcci\u00f3n IP p\u00fablica de la m\u00e1quina frontend o asignaremos una direcci\u00f3n IP el\u00e1stica a la m\u00e1quina y asignaremos la IP al dominio en No-IP. Parte de los archivos que hemos usado en la anterior fase los reutilizaremos y el resto los modificaremos y partiremos el contenido para adecuarlo a los dos niveles de esta parte.","title":"fase-1"},{"location":"arquitectura-wordpress/#scripting_1","text":"Los archivos variables.sh, config-https.sh, 000-default.conf y dir.conf los reutilizaremos y en el caso de config-https.sh lo renombraremos a https_frontend.sh ya que tenemos que obtener el certificado de Let's Encrypt en la m\u00e1quina frontend. Modificaremos el contenido de ambos scripts para que se adec\u00faen a las dos nuevas m\u00e1quinas que tenemos que crear. Los dem\u00e1s scripts los partiremos para que cada m\u00e1quina realice su funci\u00f3n. En el archivo variables.sh hay una l\u00ednea que tenemos que modificar . DB_Host=172.31.66.200 Certbot_Domain=practica09iawjrrl.ddns.net WP_Home=https://practica09iawjrrl.ddns.net WP_SiteURL=https://practica09iawjrrl.ddns.net/wordpress En la variable DB_Host tenemos que poner la direcci\u00f3n IP privada de la m\u00e1quina backend ya que es la que tendr\u00e1 el servidor MySQL para la base de datos con el usuario y la contrase\u00f1a, tambi\u00e9n podemos modificar el dominio de las variables Certbot_Domain, WP_Home y WP_SiteURL .","title":"scripting"},{"location":"arquitectura-wordpress/#install_frontendsh","text":"En esta m\u00e1quina tenemos que actualizar los repositorios y los programas instalados, instalar el servidor web Apache y los paquetes relacionados con PHP, adem\u00e1s de copiar las plantillas a sus respectivos directorios, habilitar el m\u00f3dulo rewrite y reiniciar el servidor web para aplicar los cambios. Deber\u00e1 quedar de la siguiente manera: apt-get update apt-get upgrade -y apt-get install apache2 -y apt-get install php libapache2-mod-php php-mysql -y cp ../conf/000-default.conf /etc/apache2/sites-available cp ../conf/dir.conf /etc/apache2/mods-available a2enmod rewrite systemctl restart apache2 En la m\u00e1quina frontend no instalaremos el servidor de bases de datos MySQL ya que esta instalaci\u00f3n la realizaremos en la m\u00e1quina backend.","title":"install_frontend.sh"},{"location":"arquitectura-wordpress/#install_backendsh","text":"En esta m\u00e1quina tendremos que actualizar los repositorios y los programas con respecto a los repositorios instalados y realizar la instalaci\u00f3n de MySQL y cambiar el Bind-Address para aceptar conexiones de otras m\u00e1quinas. apt-get update apt-get upgrade -y apt-get install mysql-server sed -i 's/127.0.0.1/0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf systemctl restart mysql Como esta m\u00e1quina ser\u00e1 la que tenga la base de datos de WordPress, tendremos que instalar MySQL y hacer un cambio en el Bind-Address para que acepte conexiones de nuestra m\u00e1quina frontend. Para finalizar, tendremos que reiniciar MySQL para que los cambios se apliquen.","title":"install_backend.sh"},{"location":"arquitectura-wordpress/#deploy_wordpresssh_1","text":"Usaremos este script para descargar y desplegar WordPress en la m\u00e1quina frontend, de forma que tendremos que realizar cambios en el archivo wp-config.php para especificar el nombre de la base de datos, el usuario a usar y su contrase\u00f1a, tambi\u00e9n debemos especificar la m\u00e1quina en la que se encuentra MySQL. source variables.sh wget https://wordpress.org/latest.zip -O /tmp/latest.zip apt install unzip -y unzip /tmp/latest.zip -d /var/www/html cp /var/www/html/wordpress/wp-config-sample.php /var/www/html/wordpress/wp-config.php sed -i \"s/database_name_here/$DB_Name/\" /var/www/html/wordpress/wp-config.php sed -i \"s/username_here/$DB_User/\" /var/www/html/wordpress/wp-config.php sed -i \"s/password_here/$DB_Password/\" /var/www/html/wordpress/wp-config.php sed -i \"s/localhost/$DB_Host/\" /var/www/html/wordpress/wp-config.php cp /var/www/html/wordpress/index.php /var/www/html sed -i \"s|wp-blog-header.php|wordpress/wp-blog-header.php|\" /var/www/html/index.php sed -i \"/DB_COLLATE/a define('WP_HOME', '$WP_Home');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_HOME/a define('WP_SITEURL', '$WP_SiteURL');\" /var/www/html/wordpress/wp-config.php chown www-data:www-data -R /var/www/html En este script tenemos que importar el archivo de variables e iniciar la descarga del c\u00f3digo fuente de WordPress, instalar Unzip y descomprimir el contenido de WordPress descargado en la m\u00e1quina en el directorio /var/www/html, despu\u00e9s cambiaremos el nombre del archivo wp-config-sample.php a wp-config.php para que coja la configuraci\u00f3n del archivo que vamos a modificar para especificar la base de datos, el usuario, su contrase\u00f1a y la ubicaci\u00f3n de la base de datos. Despu\u00e9s subiremos un nivel el archivo index.php para ubicarlo en /var/www/html. Modificaremos el index.php para especificar la ubicaci\u00f3n del archivo wp-blog-header.php que se encuentra en /var/www/html/wordpress y volveremos a modificar el archivo wp-config.php para a\u00f1adir dos l\u00edneas, la primera nos permite especificar la URL que tendr\u00e1 el sitio web y la segunda la ubicaci\u00f3n interna de los archivos de WordPress. Por \u00faltimo, modificaremos el propietario y el grupo de los archivos y directorios que se encuentran en /var/www/html de forma recursiva a Apache.","title":"deploy_wordpress.sh"},{"location":"arquitectura-wordpress/#deploy_backendsh","text":"Este script lo usaremos para crear la base de datos en el equipo backend. source variables.sh echo \"DROP DATABASE IF EXISTS $DB_Name\" | mysql -u root echo \"CREATE DATABASE $DB_Name CHARACTER SET utf8mb4\" | mysql -u root echo \"DROP USER IF EXISTS $DB_User@'%'\" | mysql -u root echo \"CREATE USER $DB_User@'%' IDENTIFIED BY '$DB_Password'\" | mysql -u root echo \"GRANT ALL PRIVILEGES ON $DB_Name.* TO $DB_User@'%'\" | mysql -u root Importaremos el archivo de variables y crearemos tanto la base de datos con el usuario y la contrase\u00f1a, tambi\u00e9n especificaremos los privilegios que tendr\u00e1 el usuario con respecto la base de datos, en este caso tendr\u00e1 todos los privilegios.","title":"deploy_backend.sh"},{"location":"arquitectura-wordpress/#ansible_1","text":"En este caso tambi\u00e9n reutilizaremos los archivos variables.yml , 000-default.conf.j2 , dir.conf.j2 y https.yml , en el caso del archivo variables.yml tendremos que modificar el contenido de algunas de las variables que tenemos para adecuarlas a las m\u00e1quinas y en el caso de https.yml tenemos que modificar la l\u00ednea de hosts para que se ejecute en la m\u00e1quina frontend .","title":"ansible"},{"location":"arquitectura-wordpress/#variablesyml_1","text":"Modificaremos el contenido de las siguientes variables para adecuarlo a la nueva fase, siendo opcionales tanto Domain, Home y SiteURL . Host: 172.31.66.200 Domain: practica09iawjrrl.ddns.net Home: https://practicasiaw09jrrl.ddns.net SiteURL: https://practicasiaw09jrrl.ddns.net/wordpress En la variable Host tenemos que poner la direcci\u00f3n IP privada de la m\u00e1quina que tendr\u00e1 el servidor de bases de datos .","title":"variables.yml"},{"location":"arquitectura-wordpress/#inventario_1","text":"En este archivo definiremos dos grupos, uno para la m\u00e1quina frontend y otro para la m\u00e1quina backend. [frontend] 3.231.218.67 [backend] 35.168.113.213 [all:vars] ansible_user=ubuntu ansible_ssh_private_key_file=/home/rayseink/claves/vockey.pem ansible_ssh_common_args='-o StrictHostKeyChecking=accept-new' Como necesitamos hacer la ejecuci\u00f3n de cada playbook en su m\u00e1quina correspondiente, tenemos que tener dos grupos en nuestro archivo de inventario y con la direcci\u00f3n IP p\u00fablica de la m\u00e1quina en su respectivo grupo. Por \u00faltimo, tenemos que usar all:vars para que la configuraci\u00f3n global la coja todos los grupos de m\u00e1quinas que hemos especificado.","title":"inventario"},{"location":"arquitectura-wordpress/#install_frontendyml","text":"Al igual que hicimos con los scripts, tenemos que instalar en la m\u00e1quina frontend el servidor Apache, PHP y sus respectivos m\u00f3dulos, copiar los templates locales a la m\u00e1quina remota, habilitar el m\u00f3dulo rewrite para que WordPress pueda realizar cambios en el servidor web y reiniciar el servidor web. --- - name: Instalaci\u00f3n de Apache y PHP para el equipo frontend hosts: frontend become: true tasks: - name: Inclusi\u00f3n de archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Actualizaci\u00f3n de los repositorios y de los programas instalados ansible.builtin.apt: update_cache: true upgrade: true - name: Instalaci\u00f3n de servidor web Apache ansible.builtin.apt: name: apache2 state: present - name: Instalaci\u00f3n de PHP y m\u00f3dulos de PHP para conectar con la base de datos y Apache ansible.builtin.apt: name: \"{{ PHP_Packages }}\" state: present - name: Copiado de template 000-default.conf.j2 al equipo remoto ansible.builtin.template: src: \"{{ Template_000_default.Local_Source }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 - name: Copiado de template dir.conf.j2 al equipo remoto ansible.builtin.template: src: \"{{ Template_dir.Local_Source }}\" dest: /etc/apache2/mods-available/dir.conf mode: 0644 - name: Habilitaci\u00f3n del m\u00f3dulo rewrite de Apache community.general.apache2_module: name: rewrite state: present notify: Reiniciar servidor Apache handlers: - name: Reiniciar servidor Apache ansible.builtin.service: name: apache2 state: restarted Tenemos que especificar en hosts el grupo en el que se ejecutar\u00e1 este playbook y como hicimos con los scripts, realizaremos los cambios pertinentes para preparar la m\u00e1quina frontend.","title":"install_frontend.yml"},{"location":"arquitectura-wordpress/#install_backendyml","text":"En este playbook tenemos que instalar MySQL y modificar el Bind-Address para que acepte conexiones de la red y reiniciar el servidor de bases de datos para que aplique el cambio realizado. --- - name: Instalaci\u00f3n de MySQL Server y cambio de Bind-Address hosts: backend become: true tasks: - name: Actualizaci\u00f3n de los repositorios y de los programas instalados ansible.builtin.apt: update_cache: true upgrade: true - name: Instalaci\u00f3n de MySQL Server ansible.builtin.apt: name: mysql-server state: present - name: Cambio de Bind-Address para conectar con el equipo frontend ansible.builtin.replace: path: /etc/mysql/mysql.conf.d/mysqld.cnf regexp: 127.0.0.1 replace: 0.0.0.0 notify: Reiniciar servidor MySQL handlers: - name: Reiniciar servidor MySQL ansible.builtin.service: name: mysql state: restarted Al igual que hicimos con el anterior playbook, tenemos que especificar en hosts el grupo en el que se ejecutar\u00e1 este playbook .","title":"install_backend.yml"},{"location":"arquitectura-wordpress/#httpsyml_1","text":"Este archivo lo tenemos que ejecutar en la m\u00e1quina frontend , de forma que modificaremos la l\u00ednea de hosts para que se ejecute en el grupo frontend del archivo inventario. --- - name: Descarga de Certbot mediante Snap y obtenci\u00f3n de certificado de Let's Encrypt hosts: frontend become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Desinstalaci\u00f3n de la instalaci\u00f3n previa de Certbot que viene con el sistema operativo ansible.builtin.apt: name: certbot state: absent - name: Instalaci\u00f3n de Certbot mediante Snap community.general.snap: name: certbot classic: true state: present - name: Descarga de certificado para TLS / SSL ansible.builtin.command: certbot --apache -m \"{{ Certbot.Email }}\" --agree-tos --no-eff-email -d \"{{ Certbot.Domain }}\" register: realizar_cambio changed_when: realizar_cambio.rc == 0 when: certificado | d(False) == \"descargar\" Usaremos para evitar la ejecuci\u00f3n de la descarga del certificado de Let's Encrypt el Statement When , pondremos el When al mismo nivel y justamente despu\u00e9s de la tarea concreta y usaremos una variable , certificado que por defecto no se ejecutar\u00e1 hasta que el contenido de la variable sea \"descargar\" .","title":"https.yml"},{"location":"arquitectura-wordpress/#deploy_wordpressyml_1","text":"Este playbook lo ejecutaremos en la m\u00e1quina frontend y nos servir\u00e1 para descargar el c\u00f3digo fuente de WordPress, descomprimirlo y conectar con la base de datos que se encuentra en el equipo backend. --- - name: Despliegue de WordPress en el equipo frontend hosts: frontend become: true tasks: - name: Inclusi\u00f3n de archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n de Unzip ansible.builtin.apt: name: unzip state: present - name: Descarga del c\u00f3digo fuente de WordPress ansible.builtin.get_url: url: https://wordpress.org/latest.zip dest: /tmp/wordpress.zip mode: 0664 - name: Descompresi\u00f3n de la descarga de WordPress ansible.builtin.unarchive: src: /tmp/wordpress.zip dest: /var/www/html remote_src: true - name: Borrado del archivo comprimido de WordPress ansible.builtin.file: path: /tmp/wordpress.zip state: absent - name: Copiado de archivo wp-config-sample.php a wp-config.php ansible.builtin.copy: src: /var/www/html/wordpress/wp-config-sample.php dest: /var/www/html/wordpress/wp-config.php mode: 0644 remote_src: true - name: Modificaci\u00f3n del archivo wp-config.php para especificar la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: database_name_here replace: \"{{ Database.Name }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el usuario de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: username_here replace: \"{{ Database.User }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar la contrase\u00f1a del usuario ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: password_here replace: \"{{ Database.Password }}\" - name: Modificaci\u00f3n del archivo wp-config.php para especificar el servidor de la base de datos ansible.builtin.replace: path: /var/www/html/wordpress/wp-config.php regexp: localhost replace: \"{{ Database.Host }}\" - name: Copiado del archivo index.php de html/wordpress a html ansible.builtin.copy: src: /var/www/html/wordpress/index.php dest: /var/www/html/index.php mode: 0644 remote_src: true - name: Modificaci\u00f3n del archivo index.php para la redirecci\u00f3n a WordPress ansible.builtin.replace: path: /var/www/html/index.php regexp: wp-blog-header.php replace: wordpress/wp-blog-header.php - name: Modificaci\u00f3n del archivo wp-config.php para la personalizaci\u00f3n de la URL ansible.builtin.blockinfile: path: /var/www/html/wordpress/wp-config.php insertafter: DB_COLLATE block: | define('WP_HOME', '{{ WordPress.Home }}'); define('WP_SITEURL', '{{ WordPress.SiteURL }}'); - name: Cambio de propietario y grupo para /var/www/html ansible.builtin.file: path: /var/www/html owner: www-data group: www-data recurse: true notify: Reinicio de Apache2 handlers: - name: Reinicio de Apache2 ansible.builtin.service: name: apache2 state: restarted","title":"deploy_wordpress.yml"},{"location":"arquitectura-wordpress/#deploy_backendyml","text":"Con este \u00faltimo playbook, crearemos la base de datos junto al usuario y su contrase\u00f1a en la m\u00e1quina backend. --- - name: Despliegue de la base de datos para WordPress en el equipo backend hosts: backend become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n del gestor de paquetes de Python3 ansible.builtin.apt: name: python3-pip state: present - name: Instalaci\u00f3n del m\u00f3dulo PyMySQL mediante el gestor de paquetes de Python3 para conectar conectar con el socket ansible.builtin.pip: name: pymysql state: present - name: Creaci\u00f3n de la base de datos usando el socket de PyMySQL community.mysql.mysql_db: name: \"{{ Database.Name }}\" state: present login_unix_socket: /run/mysqld/mysqld.sock - name: Creaci\u00f3n del usuario con la contrase\u00f1a para la base de datos no_log: true community.mysql.mysql_user: name: \"{{ Database.User }}\" host: '%' password: \"{{ Database.Password }}\" priv: \"{{ Database.Name }}.*:ALL\" state: present login_unix_socket: /run/mysqld/mysqld.sock","title":"deploy_backend.yml"},{"location":"arquitectura-wordpress/#mainyml_1","text":"En este archivo principal importaremos los playbooks para ejecutarlos. --- - name: Importaci\u00f3n del playbook de instalaci\u00f3n para el equipo frontend ansible.builtin.import_playbook: playbooks/install_frontend.yml - name: Importaci\u00f3n del playbook de instalaci\u00f3n para el equipo backend ansible.builtin.import_playbook: playbooks/install_backend.yml - name: Importaci\u00f3n del playbook de obtenci\u00f3n del certificado de Let's Encrypt ansible.builtin.import_playbook: playbooks/https.yml - name: Importaci\u00f3n del playbook para el despliegue en el equipo frontend ansible.builtin.import_playbook: playbooks/deploy_wordpress.yml - name: Importaci\u00f3n del playbook para el despliegue en el equipo backend ansible.builtin.import_playbook: playbooks/deploy_backend.yml","title":"main.yml"},{"location":"arquitectura-wordpress/#comprobacion-del-despliegue-de-wordpress-en-dos-niveles","text":"Ejecutaremos bien los scripts concretos en los equipos clonando el repositorio en ambas m\u00e1quinas o lanzaremos el archivo principal y el inventario mediante ansible para preparar e instalar WordPress en dos niveles. Lo mejor es montar la arquitectura mediante ansible. Mediante scripts tenemos que acceder a las m\u00e1quinas mediante SSH y clonar el repositorio en ambas m\u00e1quinas y acceder a la fase-1 al directorio scripts. Deberemos tener en cuenta que hay scripts o playbooks que tienen que ejecutarse unos antes que otros , de forma que seguiremos el siguiente orden establecido para que funcione correctamente, por ejemplo, para obtener el certificado de Let's Encrypt necesitamos que la m\u00e1quina en la que se va a descargar tenga el servidor Apache instalado . En la m\u00e1quina frontend tenemos que ejecutar en el siguiente orden : sudo ./install_frontend.sh sudo ./https_frontend.sh sudo ./deploy_wordpress.sh En la m\u00e1quina backend tenemos que ejecutar en el siguiente orden : sudo ./install_backend.sh sudo ./deploy_backend.sh Mediante ansible tenemos que dirigirnos en la m\u00e1quina local al directorio fase-1 , d\u00f3nde se encuentra tanto inventario como main.yml . Con el siguiente comando evitamos ejecutar en el playbook https , la \u00faltima tarea que consiste en la descarga del certificado de Let's Encrypt , que nos sirve para ejecuciones posteriores de los playbooks en las mismas m\u00e1quina y siempre que una tenga un certificado de Let's Encrypt, ya que dejar\u00eda bloqueado el proceso de descarga del certificado al disponer la m\u00e1quina de uno. ansible-playbook -i inventario main.yml Para nuestra primera vez con esta fase necesitamos que nuestro frontend tenga el certificado, por lo que tenemos que ejecutar: ansible-playbook -i inventario main.yml --extra-vars \"certificado=descargar\" Una vez hayamos finalizado, accederemos mediante la direcci\u00f3n IP p\u00fablica o el nombre de dominio que hemos preparado en un navegador web. Escogeremos el idioma que queramos y continuaremos. Introduciremos el nombre del sitio, el usuario de acceso al BackOffice junto a su contrase\u00f1a y el email y pulsaremos en el bot\u00f3n de Instalar WordPress. Una vez hayamos terminado de instalar WordPress, introduciremos el nombre de dominio y comprobaremos que funciona correctamente el TLS. Si queremos comprobar que en nuestro equipo backend tenemos la base de datos, accederemos mediante SSH a la instancia y ejecutaremos el comando sudo mysql -u root , despu\u00e9s usaremos show databases; y veremos las bases de datos que tenemos, accederemos a nuestra base de datos que hemos definido en el archivo de variables mediante ansible o scripting mediante use nombre_base_datos , siendo en mi caso use wordpress_db y usaremos show tables; para mostrar las tablas de la base de datos, como no hemos creado ninguna tabla antes de la instalaci\u00f3n, no deber\u00edamos tener ninguna, pero tras la instalaci\u00f3n vemos que tenemos varias tablas creadas, por lo que la instalaci\u00f3n de la base de datos se ha realizado correctamente en la m\u00e1quina backend. Para confirmar, usaremos el comando ip a para ver la direcci\u00f3n IP privada que tiene nuestra m\u00e1quina backend en la interfaz eth0.","title":"Comprobaci\u00f3n del despliegue de WordPress en dos niveles"},{"location":"arquitectura-wordpress/#fase-2","text":"Para esta fase, deberemos tener un balanceador de carga, dos frontend, un backend y un NFS Server . Con esta parte, tendremos un balanceador de carga que ir\u00e1 conmutando las peticiones que reciba a los frontend y estos a su vez se conectar\u00e1n con el servidor NFS para servir las p\u00e1ginas que est\u00e1n almacenadas en el servidor NFS. Cuando tengamos listas las m\u00e1quinas, en No-IP crearemos un dominio con la direcci\u00f3n IP de la m\u00e1quina que har\u00e1 de balanceador de carga.","title":"fase-2"},{"location":"arquitectura-wordpress/#scripting_2","text":"Comenzaremos esta pr\u00e1ctica creando los scripts y las plantillas que necesitamos para realizar esta parte.","title":"scripting"},{"location":"arquitectura-wordpress/#000-default-balancerconf","text":"Este archivo es para nuestro balanceador de carga para que haga el proxy inverso a las m\u00e1quinas frontend, deberemos tener tantos BalancerMember como m\u00e1quinas frontend tengamos. <VirtualHost *:80> <Proxy balancer://cluster-frontend> # Frontend 1 BalancerMember http://IP_HTTP_SERVER_1 # Frontend 2 BalancerMember http://IP_HTTP_SERVER_2 </Proxy> ProxyPass / balancer://cluster-frontend/ </VirtualHost>","title":"000-default-balancer.conf"},{"location":"arquitectura-wordpress/#000-default-frontendconf","text":"Con este archivo haremos que los equipos frontend busquen en los directorios del sitio web los archivos .htaccess. <VirtualHost *:80> #ServerName www.example.org ServerAdmin webmaster@localhost DocumentRoot /var/www/html #LogLevel info ssl:warm <Directory \"/var/www/html\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost>","title":"000-default-frontend.conf"},{"location":"arquitectura-wordpress/#dirconf_1","text":"Este archivo nos permite cambiar el orden de prioridades a la hora de servir el contenido de las m\u00e1quinas frontend, le daremos m\u00e1s prioridad al archivo index.php que al archivo index.html <IfModule mod_dir.c> DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm </IfModule>","title":"dir.conf"},{"location":"arquitectura-wordpress/#exports","text":"Este archivo nos permite establecer en la m\u00e1quina NFS Server el directorio que vamos a compartir, a la red en la que compartiremos el directorio y las opciones para el directorio. /var/www/html 172.31.0.0/16(rw,sync,no_root_squash,no_subtree_check)","title":"exports"},{"location":"arquitectura-wordpress/#install_nfs_serversh","text":"Este script nos permitir\u00e1 realizar el despliegue del servidor NFS que tengamos dedicado a almacenamiento y d\u00f3nde estar\u00e1n las p\u00e1ginas web. apt update apt upgrade -y apt install nfs-kernel-server -y mkdir -p /var/www/html chown nobody:nogroup /var/www/html cp ../conf/exports /etc/exports systemctl restart nfs-kernel-server En la m\u00e1quina NFS actualizaremos los repositorios y actualizaremos los programas con respecto a los repositorios descargados, despu\u00e9s instalaremos el servidor NFS (nfs-kernel-server), cuando se realice la descarga e instalaci\u00f3n de NFS Server, crearemos el directorio html usando mkdir y el modificador -p para crear todos los directorios si no est\u00e1n creados. Al directorio creado le cambiaremos tanto el propietario como el grupo para que las m\u00e1quinas puedan montar el directorio creado y acceder a los archivos y directorios que contendr\u00e1n. Despu\u00e9s, copiaremos el archivo exports, que contiene el directorio a compartir, a qu\u00e9 red y las opciones, a la ruta /etc , por \u00faltimo, tendremos que reiniciar el NFS Server.","title":"install_nfs_server.sh"},{"location":"arquitectura-wordpress/#deploy_wordpresssh_2","text":"Este script como ya lo hemos realizado en la segunda fase, fase-1, lo explicar\u00e9 de forma superficial ya que no tiene cambios con respecto a la anterior fase. source variables.sh wget https://wordpress.org/latest.zip -O /tmp/latest.zip apt install unzip -y rm -rf /var/www/html/wordpress unzip /tmp/latest.zip -d /var/www/html cp /var/www/html/wordpress/wp-config-sample.php /var/www/html/wordpress/wp-config.php sed -i \"s/database_name_here/$DB_Name/\" /var/www/html/wordpress/wp-config.php sed -i \"s/username_here/$DB_User/\" /var/www/html/wordpress/wp-config.php sed -i \"s/password_here/$DB_Password/\" /var/www/html/wordpress/wp-config.php sed -i \"s/localhost/$DB_Host/\" /var/www/html/wordpress/wp-config.php cp /var/www/html/wordpress/index.php /var/www/html sed -i \"s|wp-blog-header.php|wordpress/wp-blog-header.php|\" /var/www/html/index.php sed -i \"/DB_COLLATE/a define('WP_HOME', '$WP_Home');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_HOME/a define('WP_SITEURL', '$WP_SiteURL');\" /var/www/html/wordpress/wp-config.php sed -i \"/WP_SITEURL/a \\$_SERVER['HTTPS'] = 'on';\" /var/www/html/wordpress/wp-config.php chown www-data:www-data -R /var/www/html Tenemos que importar el archivo de variables, descargar el c\u00f3digo fuente de WordPress, instalar Unzip y descomprimir los archivos de WordPress en /var/www/html, despu\u00e9s copiar el archivo wp-config-sample.php para renombrar el archivo wp-config.php y modificar su contenido, tambi\u00e9n subiremos un nivel el archivo index.php y modificaremos su contenido y por \u00faltimo, cambiaremos tanto el propietario como el grupo a Apache de todos los archivos que hay en /var/www/html. sed -i \"/WP_SITEURL/a \\$_SERVER['HTTPS'] = 'on';\" /var/www/html/wordpress/wp-config.php Para que nuestra arquitectura funcione correctamente, tenemos que a\u00f1adir a wp-config.php el c\u00f3digo $_SERVER['HTTPS'] = 'on'; ya que como tenemos conexiones HTTP entre el balanceador de carga y los frontales , es posible que nos de problemas el hecho de que se mezclen peticiones HTTP con HTTPS , de forma que con esa l\u00ednea hacemos que \u00fanicamente se realicen mediante HTTPS . Tenemos que usar el backslash o \\ para hacer una secuencia de escape para el s\u00edmbolo \\$ ya que el comando SED coger\u00eda el s\u00edmbolo y su continuaci\u00f3n como una variable . Este script lo ejecutaremos en la m\u00e1quina que tiene el NFS Server .","title":"deploy_wordpress.sh"},{"location":"arquitectura-wordpress/#deploy_balancersh","text":"Necesitaremos que nuestra m\u00e1quina que hace de balanceador de carga tenga un proxy inverso para que las peticiones que reciba las pase a los frontend para que atiendan las peticiones. source variables.sh apt update apt upgrade -y apt install apache2 -y a2enmod proxy a2enmod proxy_http a2enmod proxy_ajp a2enmod rewrite a2enmod deflate a2enmod headers a2enmod proxy_balancer a2enmod proxy_connect a2enmod proxy_html a2enmod lbmethod_byrequests cp ../conf/000-default-balancer.conf /etc/apache2/sites-available/000-default.conf sed -i \"s/IP_HTTP_SERVER_1/$IP_HTTP_Server_1/\" /etc/apache2/sites-available/000-default.conf sed -i \"s/IP_HTTP_SERVER_2/$IP_HTTP_Server_2/\" /etc/apache2/sites-available/000-default.conf systemctl restart apache2 Tenemos que integrar las variables en el script, despu\u00e9s, actualizar los repositorios y los programas con respecto a los repositorios, despu\u00e9s, instalaremos el servidor Apache y habilitaremos los m\u00f3dulos necesarios para realizar el proxy inverso, copiaremos nuestra plantilla a sites-available de Apache, modificaremos el contenido de la plantilla para agregar las direcciones IP de los frontend y reiniciaremos el servidor Apache.","title":"deploy_balancer.sh"},{"location":"arquitectura-wordpress/#install_frontendsh_1","text":"Es igual al de la anterior fase, lo \u00fanico que cambia es que tenemos una plantilla distinta para permitir el uso de los archivos .htaccess. apt-get update apt-get upgrade -y apt-get install apache2 -y apt-get install php libapache2-mod-php php-mysql -y cp ../conf/000-default-frontend.conf /etc/apache2/sites-available cp ../conf/dir.conf /etc/apache2/mods-available a2enmod rewrite systemctl restart apache2","title":"install_frontend.sh"},{"location":"arquitectura-wordpress/#install_nfs_clientsh","text":"Con este script realizaremos el montaje del directorio /var/www/html de la m\u00e1quina NFS Server en los dos frontend para que puedan acceder a los sitios web y agregaremos una l\u00ednea en el archivo /etc/fstab para realizar el montaje del directorio de forma autom\u00e1tica cuando alguna de las m\u00e1quinas frontend se reinicie. source variables.sh apt install nfs-common -y mount $Private_IP_NFS_Server:/var/www/html /var/www/html echo \"$Private_IP_NFS_Server:/var/www/html /var/www/html nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 0 0\" >> /etc/fstab Realizaremos la importaci\u00f3n del archivo de variables e instalaremos el cliente de NFS. Despu\u00e9s, montaremos mediante el comando mount junto a la direcci\u00f3n IP que est\u00e1 en el archivo de variables y la ruta del directorio, /var/www/html, en el directorio /var/www/html de las m\u00e1quinas frontend . Por \u00faltimo, con un echo a\u00f1adiremos la direcci\u00f3n IP de la m\u00e1quina NFS Server junto al directorio que hay que montar y la ruta d\u00f3nde se montar\u00e1, especificaremos que es nfs, auto para que se auto monte al iniciar la m\u00e1quina frontend y varias opciones m\u00e1s mediante una redirecci\u00f3n no destructiva ( >> ) a la ruta /etc/fstab .","title":"install_nfs_client.sh"},{"location":"arquitectura-wordpress/#install_backendsh_1","text":"Este script tambi\u00e9n lo hemos visto en la fase anterior y nos sirve para instalar el servidor de bases de datos, MySQL. apt-get update apt-get upgrade -y apt-get install mysql-server -y sed -i 's/127.0.0.1/0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf systemctl restart mysql","title":"install_backend.sh"},{"location":"arquitectura-wordpress/#deploy_backendsh_1","text":"Tambi\u00e9n lo hemos visto en la anterior fase, nos sirve para crear la base de datos junto al usuario y la contrase\u00f1a del usuario, adem\u00e1s de dar privilegios al usuario sobre esa base de datos. source variables.sh echo \"DROP DATABASE IF EXISTS $DB_Name\" | mysql -u root echo \"CREATE DATABASE $DB_Name CHARACTER SET utf8mb4\" | mysql -u root echo \"DROP USER IF EXISTS $DB_User@'%'\" | mysql -u root echo \"CREATE USER $DB_User@'%' IDENTIFIED BY '$DB_Password'\" | mysql -u root echo \"GRANT ALL PRIVILEGES ON $DB_Name.* TO $DB_User@'%'\" | mysql -u root","title":"deploy_backend.sh"},{"location":"arquitectura-wordpress/#ansible_2","text":"Realizaremos la misma operaci\u00f3n de esta fase, solo que en este caso la realizaremos mediante Ansible.","title":"ansible"},{"location":"arquitectura-wordpress/#inventario_2","text":"En nuestro archivo de inventario definiremos cuatro grupos, el primero para el balanceador de carga, el segundo para las m\u00e1quinas frontend y que tendr\u00e1n el cliente NFS, el tercer grupo para la m\u00e1quina backend y el cuarto grupo para la m\u00e1quina que tendr\u00e1 el NFS Server. [balancer] 3.233.217.136 [frontend_nfs_client] 18.207.158.92 18.206.16.232 [backend] 100.27.49.133 [nfs_server] 3.237.34.73 [all:vars] ansible_user=ubuntu ansible_ssh_private_key_file=/home/rayseink/claves/vockey.pem ansible_ssh_common_args='-o StrictHostKeyChecking=accept-new'","title":"inventario"},{"location":"arquitectura-wordpress/#variablesyml_2","text":"Podemos reciclar el anterior archivo de variables ya que tendremos que a\u00f1adir un poco m\u00e1s de contenido y cambiar el contenido de algunas variables. En este archivo vamos a agrupar las variables que se ejecutan en una misma m\u00e1quina. Balancer: Local_Source: ../templates/000-default-balancer.conf.j2 IP_HTTP_Server_1: 172.31.77.79 IP_HTTP_Server_2: 172.31.78.66 Con estas tres siguientes variables establecemos la ruta local del template 000-default-balancer.conf.j2 para el balanceador de carga y las direcciones IP privadas de las m\u00e1quinas frontend para el template. Frontend: Local_Source_000: ../templates/000-default-frontend.conf.j2 DocumentRoot: /var/www/html Local_Source_dir: ../templates/dir.conf.j2 Directory_index: DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm Tambi\u00e9n estableceremos la ruta local del template 000-default-frontend.conf.j2 para los equipos frontend y la variable del DocumentRoot d\u00f3nde se alojan los sitios web para el template.Tambi\u00e9n estableceremos la ruta local del archivo dir.conf.j2 y el contenido del template para priorizar el archivo index.php sobre el index.html. NFS_Server: Local_Source_exports: ../templates/exports.j2 Shared_directory_exports: /var/www/html Range_AWS_Private_IP_exports: 172.31.0.0/16 NFS_Options_exports: rw,sync,no_root_squash,no_subtree_check Private_IP_NFS_Server: 172.31.65.63 Las siguientes variables son la localizaci\u00f3n del template exports.j2 en el equipo local, el directorio del servidor NFS que hay que compartir, el rango de direcciones desde d\u00f3nde tiene que aceptar el servidor NFS peticiones de compartici\u00f3n del directorio compartido, las opciones para el archivo exports y la IP privada de la m\u00e1quina NFS Server.","title":"variables.yml"},{"location":"arquitectura-wordpress/#000-default-balancerconfj2","text":"Con este template estableceremos las direcciones IP de las m\u00e1quinas frontend y pasaremos dicho template a la m\u00e1quina que har\u00e1 de balanceador de carga. Deberemos tener tantos BalancerMember como frontend tengamos. <VirtualHost *:80> <Proxy balancer://cluster-frontend> # Frontend 1 BalancerMember http://{{ Balancer.IP_HTTP_Server_1 }} # Frontend 2 BalancerMember http://{{ Balancer.IP_HTTP_Server_2 }} </Proxy> ProxyPass / balancer://cluster-frontend/ </VirtualHost>","title":"000-default-balancer.conf.j2"},{"location":"arquitectura-wordpress/#000-default-frontendconfj2","text":"Usaremos este template para permitir el uso de archivos .htaccess en el directorio /var/www/html de las m\u00e1quinas frontend y leer correctamente el contenido de los sitios web. <VirtualHost *:80> #ServerName www.example.org ServerAdmin webmaster@localhost DocumentRoot {{ Frontend.DocumentRoot }} #LogLevel info ssl:warm <Directory \"{{ Frontend.DocumentRoot }}\"> AllowOverride All </Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </VirtualHost>","title":"000-default-frontend.conf.j2"},{"location":"arquitectura-wordpress/#exportsj2","text":"Este template nos permite establecer el directorio a compartir en el NFS Server, el rango de direcciones IP que admite para compartir y las opciones que tiene el directorio que vamos a compartir. {{ NFS_Server.Shared_directory_exports }} {{ NFS_Server.Range_AWS_Private_IP_exports }}({{ NFS_Options_exports }})","title":"exports.j2"},{"location":"arquitectura-wordpress/#install_nfs_serveryml","text":"Este playbook nos permitir\u00e1 realizar la instalaci\u00f3n del servidor NFS en la m\u00e1quina que hemos definido para este playbook en el archivo inventario y la compartici\u00f3n del directorio que nos interesa, /var/www/html. --- - name: Instalaci\u00f3n de servidor NFS y compartici\u00f3n de directorio hosts: nfs_server become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Actualizaci\u00f3n de los repositorios y de los programas ansible.builtin.apt: update_cache: true only_upgrade: true - name: Instalaci\u00f3n del servidor NFS ansible.builtin.apt: name: nfs-kernel-server state: present Incluiremos el archivo de variables en el playbook, actualizaremos los repositorios y los programas con respecto a los repositorios, despu\u00e9s instalaremos el servidor NFS. - name: Creaci\u00f3n del directorio que hay que compartir ansible.builtin.file: path: /var/www/html state: directory mode: 0755 owner: nobody group: nogroup - name: Copiado de template exports.j2 al equipo remoto ansible.builtin.template: src: \"{{ NFS_Server.Local_Source_exports }}\" dest: /etc/exports mode: 0644 - name: Reinicio del servidor NFS ansible.builtin.service: name: nfs-kernel-server state: restarted Crearemos el directorio html o la ruta completa si no existe y cambiaremos el propietario y el grupo para que las m\u00e1quinas frontend puedan acceder al directorio, despu\u00e9s, pasaremos el template exports.j2 a la m\u00e1quina y le cambiaremos el nombre, por \u00faltimo, reiniciaremos el servidor NFS para aplicar los cambios realizados.","title":"install_nfs_server.yml"},{"location":"arquitectura-wordpress/#deploy_wordpressyml_2","text":"Este playbook lo ejecutaremos en la m\u00e1quina NFS Server para desplegar WordPress en nuestra arquitectura, es casi id\u00e9ntico al de la fase anterior salvo por hosts . --- - name: Despliegue de WordPress en el servidor NFS hosts: nfs_server become: true - name: Modificaci\u00f3n del archivo wp-config.php para la personalizaci\u00f3n de la URL ansible.builtin.blockinfile: path: /var/www/html/wordpress/wp-config.php insertafter: DB_COLLATE block: | define( 'WP_HOME', '{{ WordPress.Home }}' ); define( 'WP_SITEURL', '{{ WordPress.SiteURL }}' ); $_SERVER['HTTPS'] = 'on'; - name: Borrado del marcado del m\u00f3dulo blockinfile ansible.builtin.lineinfile: path: /var/www/html/wordpress/wp-config.php regexp: ANSIBLE MANAGED BLOCK state: absent Puesto que tenemos que a\u00f1adir tres l\u00edneas, usaremos el m\u00f3dulo blockinfile, es posible que con el m\u00f3dulo nos a\u00f1ada un par de l\u00edneas para indicar el inicio de la inserci\u00f3n de c\u00f3digo y el final , por lo que tenemos que borrar dichas l\u00edneas para que no den problemas , para ello, usaremos el m\u00f3dulo lineinfile, buscaremos con toda la precisi\u00f3n posible las l\u00edneas para borrarlas y marcaremos su state como absent para eliminarlas.","title":"deploy_wordpress.yml"},{"location":"arquitectura-wordpress/#deploy_balanceryml","text":"Con este playbook realizaremos el despliegue de nuestro balanceador de carga por software para que pase las peticiones HTTPS que reciba a los frontend mediante HTTP y que estas m\u00e1quinas devuelvan las respuestas al balanceador de carga. Debemos actualizar los repositorios y los programas instalados con respecto a los repositorios descargados, instalar el servidor Apache y habilitar varios m\u00f3dulos para realizar el proxy inverso. - name: Copiado de template 000-default-balancer.conf.j2 al equipo remoto ansible.builtin.template: src: \"{{ Balancer.Local_Source }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 notify: Reinicio de servidor Apache handlers: - name: Reinicio de servidor Apache ansible.builtin.service: name: apache2 state: restarted Por \u00faltimo, pasaremos nuestro template 000-default-balancer.conf.j2 al equipo remoto y reiniciaremos el servidor Apache.","title":"deploy_balancer.yml"},{"location":"arquitectura-wordpress/#install_frontendyml_1","text":"Realizaremos la instalaci\u00f3n de Apache, PHP y los m\u00f3dulos de PHP para conectar con Apache y MySQL en las m\u00e1quinas frontend. Tambi\u00e9n tenemos que pasar dos templates, uno para establecer el DocumentRoot a la ruta /var/www/html y el otro para establecer prioridades con respecto a los archivos index. --- - name: Instalaci\u00f3n de Apache y habilitaci\u00f3n de m\u00f3dulo para Apache en los equipos frontend hosts: frontend_nfs_client become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Copiado de template 000-default-frontend.conf.j2 a los equipos remotos ansible.builtin.template: src: \"{{ Frontend.Local_Source_000 }}\" dest: /etc/apache2/sites-available/000-default.conf mode: 0644 - name: Copiado de template dir.conf.j2 a los equipos remotos ansible.builtin.template: src: \"{{ Frontend.Local_Source_dir }}\" dest: /etc/apache2/mods-available/dir.conf mode: 0644 Esta es una parte del archivo YAML, tenemos que establecer el grupo de m\u00e1quinas sobre las que ejecutar el playbook e incluir nuestro archivo de variables, con el primer template establecemos el DocumentRoot que por defecto servir\u00e1n los frontend y con el segundo establecemos la prioridad del index.php sobre el index.html.","title":"install_frontend.yml"},{"location":"arquitectura-wordpress/#install_nfs_clientyml","text":"Este playbook es para instalar el cliente NFS en las m\u00e1quinas frontend y poder montar el directorio /var/www/html de la m\u00e1quina NFS Server en el directorio local /var/www/html de las m\u00e1quinas y poder servir el mismo contenido teniendo varias m\u00e1quinas frontend. --- - name: Instalaci\u00f3n de cliente NFS para conectar con el servidor NFS hosts: frontend_nfs_client become: true tasks: - name: Inclusi\u00f3n del archivo de variables ansible.builtin.include_vars: ../vars/variables.yml - name: Instalaci\u00f3n de NFS cliente ansible.builtin.apt: name: nfs-common state: present - name: Montado del directorio compartido del servidor NFS en los clientes ansible.posix.mount: path: /var/www/html src: \"{{ NFS_Server.Private_IP_NFS_Server }}:/var/www/html\" fstype: nfs state: mounted opts: auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 Tenemos que establecer el grupo sobre el que ejecutar este playbook, las m\u00e1quinas frontend, incluir el archivo de variables y realizar la instalaci\u00f3n del cliente NFS, por \u00faltimo, con el FQCN ansible.posix.mount realizaremos el montado del directorio de la m\u00e1quina NFS Server mediante su direcci\u00f3n IP y la ruta del directorio compartido, tambi\u00e9n estableceremos el tipo de file system (fstype), el state mount para que se monte y se configure el archivo /etc/fstab para a\u00f1adir la direcci\u00f3n IP y la ruta junto a fstype y opts.","title":"install_nfs_client.yml"},{"location":"arquitectura-wordpress/#mainyml_2","text":"Estableceremos el orden de ejecuci\u00f3n de los playbooks en nuestro archivo principal. --- - name: Ejecuci\u00f3n del playbook de instalaci\u00f3n del servidor NFS ansible.builtin.import_playbook: playbooks/install_nfs_server.yml - name: Ejecuci\u00f3n del playbook de despliegue de WordPress en el servidor NFS ansible.builtin.import_playbook: playbooks/deploy_wordpress.yml - name: Ejecuci\u00f3n del playbook de despliegue del balanceador de carga ansible.builtin.import_playbook: playbooks/deploy_balancer.yml - name: Ejecuci\u00f3n del playbook de obtenci\u00f3n del certificado de Let's Encrypt ansible.builtin.import_playbook: playbooks/https.yml when: certificado | d(False) == \"descargar\" - name: Ejecuci\u00f3n del playbook de preparaci\u00f3n de los equipos frontend ansible.builtin.import_playbook: playbooks/install_frontend.yml - name: Ejecuci\u00f3n del playbook de instalaci\u00f3n de cliente NFS y conexi\u00f3n con el servidor ansible.builtin.import_playbook: playbooks/install_nfs_client.yml - name: Ejecuci\u00f3n del playbook de preparaci\u00f3n del equipo backend ansible.builtin.import_playbook: playbooks/install_backend.yml - name: Ejecuci\u00f3n del playbook de creaci\u00f3n de la base de datos con usuario y contrase\u00f1a ansible.builtin.import_playbook: playbooks/deploy_backend.yml Debemos tener un orden de ejecuci\u00f3n correcto ya que de no ser as\u00ed, podr\u00eda no funcionar. Primero ejecutaremos la instalaci\u00f3n del servidor NFS e inmediatamente despu\u00e9s el despliegue de WordPress en la m\u00e1quina NFS Server. A continuaci\u00f3n, realizaremos el despliegue del balanceador de carga y despu\u00e9s la obtenci\u00f3n del certificado de Let's Encrypt en el balanceador de carga. Despu\u00e9s, realizaremos la preparaci\u00f3n de los equipos frontend para instalar tanto Apache como PHP y los m\u00f3dulos de PHP para conectar con MySQL y Apache, tambi\u00e9n realizaremos la instalaci\u00f3n del cliente NFS en los equipos frontend y el montaje de la unidad de red del equipo NFS Server. Por \u00faltimo, prepararemos el equipo backend y crearemos la base de datos. El orden establecido en main.yml puede ser un poco aleatorio, aunque s\u00ed que es necesario que un playbook concreto se ejecute antes de otro playbook para realizar correctamente la fase , en este caso, tenemos que preparar la m\u00e1quina NFS Server y compartir el directorio antes de que en los equipos frontend se instale el cliente NFS y se haga el montado del directorio , ya que de ser al contrario dar\u00eda fallos. Tambi\u00e9n debemos tener en cuenta que antes de descargar el certificado de Let's Encrypt en el balanceador de carga, debemos tener instalado el servidor Apache .","title":"main.yml"},{"location":"arquitectura-wordpress/#comprobacion-del-despliegue-de-wordpress-en-tres-niveles","text":"Seguiremos un orden concreto y correcto para esta pr\u00e1ctica en cuanto a la ejecuci\u00f3n de los scripts y el orden establecido anteriormente de ejecuci\u00f3n de los playbooks de Ansible. Debemos tener en cuenta que si queremos ejecutar los scripts, debemos clonar el repositorio en todas las m\u00e1quinas. Mediante scripts en la m\u00e1quina NFS Server debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./install_nfs_server.sh sudo ./deploy_wordpress.sh Con este orden preparemos primero la m\u00e1quina NFS Server para realizar la compartici\u00f3n del directorio /var/www/html y de los archivos de WordPress en las m\u00e1quinas frontend tras realizar el despliegue de WordPress en la m\u00e1quina. Mediante scripts en la m\u00e1quina balanceador de carga debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./deploy_balancer.sh sudo ./https_balancer.sh Con este orden hacemos que el balanceador de carga instale Apache y realice la configuraci\u00f3n necesaria para actuar como proxy inverso con los frontales, una vez se haga el despliegue del balanceador, se obtendr\u00e1 el certificado de Let's Encrypt y dispondremos de HTTPS en las peticiones entrantes al balanceador. Mediante scripts en las m\u00e1quinas frontend debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./install_frontend.sh sudo ./install_nfs_client.sh Con este orden instalamos Apache, PHP, los m\u00f3dulos de PHP necesarios para conectar con MySQL y Apache, tambi\u00e9n preparamos el directorio /var/www/html para conectar con la unidad de red del servidor NFS. Mediante scripts en la m\u00e1quina backend debemos ejecutar el siguiente orden y en la ruta d\u00f3nde se encuentran: sudo ./install_backend.sh sudo ./deploy_backend.sh Tal y como hicimos en la anterior fase, podemos saltar en este caso la ejecuci\u00f3n completa del playbook https.yml mediante el Statement When , por lo que para nuestra primera ejecuci\u00f3n tendremos que usar el comando: ansible-playbook -i inventario main.yml --extra-vars \"certificado=descargar\" Cuando hayamos realizado la ejecuci\u00f3n mediante scripts o Ansible, accederemos mediante la direcci\u00f3n IP o el nombre de dominio que hemos puesto en No-IP. Escogeremos el idioma que queremos y continuaremos. Podremos los datos del sitio y pulsaremos en Instalar WordPress. Cuando hayamos realizado la instalaci\u00f3n de WordPress, accederemos mediante el dominio que hemos asignado para comprobar que nuestro certificado en el balanceador de carga funciona correctamente. Accederemos al BackOffice de WordPress para comprobar que funciona correctamente, en la URL tenemos que poner: https://nombre-dominio/wp-login.php \u00d3 https://nombre-dominio/wordpress/wp-login.php De cualquiera de las formas nos sirven ya que con la primera usamos la redirecci\u00f3n que hemos establecido en wp-config.php y con la segunda forma hacemos referencia al directorio y al archivo de acceso, ponemos los datos de acceso que hemos establecido durante la instalaci\u00f3n en el navegador web y veremos que podemos acceder sin problemas. Mediante SSH accederemos a una de las m\u00e1quinas frontend y usaremos el comando cat /etc/fstab para comprobar que se ha modificado correctamente el archivo con la direcci\u00f3n IP privada del servidor NFS y el directorio compartido, el fstype y las options configuradas para los clientes.","title":"Comprobaci\u00f3n del despliegue de WordPress en tres niveles"},{"location":"prestashop-en-docker/","text":"PrestaShop en Docker \u00b6 En esta pr\u00e1ctica realizaremos la misma operaci\u00f3n que en la pr\u00e1ctica anterior, salvo por el contenedor que tenemos que usar, en vez de usar WordPress, usaremos PrestaShop y adici\u00f3n de m\u00e1s variables. Puesto que de PrestaShop no hay una imagen oficial, usaremos bitnami/prestashop . Tambi\u00e9n asignaremos a la instancia al menos 8GB de memoria RAM para que PrestaShop se cree en poco tiempo. Warning Puede que las im\u00e1genes no se vean Crearemos un repositorio y lo clonaremos en nuestra m\u00e1quina local, apenas hay cambios con respecto a la pr\u00e1ctica anterior, por lo que usaremos casi todo el c\u00f3digo de la anterior pr\u00e1ctica para aprovechar el tiempo y realizar \u00fanicamente la parte del contenedor de PrestaShop. La estructura del repositorio es la siguiente: ansible inventario inventario --> Archivo playbooks delete_compose.yaml deploy_compose.yaml install_docker.yaml vars variables.yaml main.yaml docker .env docker-compose.yaml terraform main.tf variables.tf docker \u00b6 En esta parte tendremos lo mismo que en la anterior pr\u00e1ctica, salvo por el cambio de WordPress a PrestaShop en el archivo de docker-compose.yaml y la agregaci\u00f3n de variables al archivo .env , por lo que explicar\u00e9 las adiciones en ambos archivos. .env \u00b6 Antes de entrar con el archivo docker-compose.yaml , asignaremos las variables que hay que usar para PrestaShop. La primera variable, USER_FIRST_NAME , nos permitir\u00e1 establecer el nombre del propietario de la tienda de PrestaShop, con la segunda variable, USER_LAST_NAME , servir\u00e1 para establecer los apellidos o el segundo nombre del propietario. Con la variable PRESTASHOP_ACCESS_EMAIL establecemos el correo electr\u00f3nico que se usar\u00e1 en PrestaShop para el acceso al Back-Office, con la variable PRESTASHOP_ACCESS_PASSWORD estableceremos la contrase\u00f1a de acceso al Back-Office. La siguiente variable, PRESTASHOP_DOMAIN , nos servir\u00e1 para indicar el nombre de dominio que tiene la tienda online, con PRESTASHOP_COUNTRY establecemos el pa\u00eds de la tienda y con PRESTASHOP_LANGUAGE establecemos el idioma para PrestaShop. USER_FIRST_NAME=\"Juan Ram\u00f3n\" USER_LAST_NAME=\"Rueda Lao\" PRESTASHOP_ACCESS_EMAIL=ujgu.ltwjr72@pihey.com PRESTASHOP_ACCESS_PASSWORD=Admin123@45 PRESTASHOP_DOMAIN=jrrlprestashop14.ddns.net PRESTASHOP_COUNTRY_LANGUAGE=es docker-compose.yaml \u00b6 Comenzaremos directamente con el contenedor de PrestaShop, usaremos la imagen bitnami/prestashop:8.0.1 , esta es la \u00faltima versi\u00f3n, por lo que por buenas pr\u00e1cticas, no usaremos latest o dejaremos en blanco la versi\u00f3n ya que al subirse otra versi\u00f3n nueva de la imagen, nos puede dar fallos al implementarla. Esta imagen realiza la instalaci\u00f3n de PrestaShop por defecto, por lo que usaremos las variables de entorno que necesitemos y queramos para personalizar el sitio web. Con la variable de entorno PRESTASHOP_FIRST_NAME asignamos el nombre del propietario que hemos declarado en el archivo de variables, con la segunda variable, PRESTASHOP_LAST_NAME estableceremos la variable para los apellidos o el segundo nombre del usuario, con la tercera variable, PRESTASHOP_EMAIL asignaremos el email que se usar\u00e1 para el acceso al Back-Office y con PRESTASHOP_PASSWORD estableceremos la contrase\u00f1a de acceso al Back-Office. En la variable PRESTASHOP_HOST , pondremos la variable para el dominio de la tienda online, en la variable PRESTASHOP_ENABLE_HTTPS=yes estableceremos que la tienda use TLS / SSL para agregar seguridad. En PRESTASHOP_COUNTRY asignaremos la variable para establecer el pa\u00eds y en PRESTASHOP_LANGUAGE usaremos la variable para indicar el idioma de la tienda. Para ir finalizando con las variables de entorno de PrestaShop, usaremos la variable PRESTASHOP_DATABASE_HOST para indicar el contenedor que tiene la base de datos, con la variable PRESTASHOP_DATABASE_NAME indicaremos la base de datos que se usar\u00e1 para crear las tablas y los registros, con PRESTASHOP_DATABASE_USER estableceremos el usuario de la base de datos y con PRESTASHOP_DATABASE_PASSWORD la contrase\u00f1a del usuario de la base de datos. A continuaci\u00f3n, si no queremos evitar perder datos, hay que usar un volumen gestionado por Docker, en este caso la variable del volumen es prestashop_data y la tenemos que vincular al directorio /bitnami/prestashop , despu\u00e9s, el contenedor esperar\u00e1 a que el contenedor mysql est\u00e9 saludable para poder ejecutarse y con un restart always para que se reinicie en cuanto tenga alg\u00fan fallo y por \u00faltimo, el contenedor estar\u00e1 conectado a las networks frontend-network y backend-network para poder servir su contenido y conectarse con el contenedor mysql. prestashop: image: bitnami/prestashop:8.0.1 # ports: # - 80:80 environment: - PRESTASHOP_FIRST_NAME=${USER_FIRST_NAME} - PRESTASHOP_LAST_NAME=${USER_LAST_NAME} - PRESTASHOP_EMAIL=${PRESTASHOP_ACCESS_EMAIL} - PRESTASHOP_PASSWORD=${PRESTASHOP_ACCESS_PASSWORD} - PRESTASHOP_HOST=${PRESTASHOP_DOMAIN} - PRESTASHOP_ENABLE_HTTPS=yes - PRESTASHOP_COUNTRY=${PRESTASHOP_COUNTRY_LANGUAGE} - PRESTASHOP_LANGUAGE=${PRESTASHOP_COUNTRY_LANGUAGE} - PRESTASHOP_DATABASE_HOST=mysql - PRESTASHOP_DATABASE_NAME=${MYSQL_DATABASE} - PRESTASHOP_DATABASE_USER=${MYSQL_USER} - PRESTASHOP_DATABASE_PASSWORD=${MYSQL_PASSWORD} volumes: - prestashop_data:/bitnami/prestashop depends_on: mysql: condition: service_healthy restart: always networks: - frontend-network - backend-network Por defecto, esta imagen de PrestaShop usa el puerto 8080 de Apache, por lo que para conectar con el contenedor prestashop, hay que indicar el contenedor con el puerto 8080. Tambi\u00e9n modificaremos el dominio de DOMAINS para que adecuarlo a la pr\u00e1ctica . https-portal: image: steveltn/https-portal ports: - '80:80' - '443:443' volumes: - ssl_certs_data:/var/lib/https-portal environment: # DOMAINS: 'localhost -> http://prestashop:8080' # STAGE: 'local' DOMAINS: 'jrrlprestashop14.ddns.net -> http://prestashop:8080' STAGE: 'production' restart: always networks: - frontend-network Proceso de trabajo \u00b6 Como hicimos con la pr\u00e1ctica anterior, ejecutaremos primero Terraform para montar la infraestructura en AWS y la IP el\u00e1stica que nos devuelva, la pondremos en el archivo inventario de Ansible. Despu\u00e9s ejecutaremos el archivo main.yaml con las dos primeras variables para instalar Docker, Docker Compose y pasar los archivos que hemos creado de Docker Compose, adem\u00e1s de ejecutar la infraestructura con el segundo playbook. ansible-playbook -i inventario/inventario main.yaml --extra-vars \"instalar=docker desplegar=compose\" Usaremos la IP el\u00e1stica de la instancia de AWS para asignar el dominio a la IP el\u00e1stica en No-IP . Cuando Ansible termine de ejecutar todos los playbooks que quer\u00edamos ejecutar, esperaremos un par de minutos a que la infraestructura de contenedores est\u00e9 completamente lista y accederemos al dominio que hemos preparado. Si todo ha ido bien, tendr\u00e1 que salir la tienda online montada. Lo siguiente que haremos ser\u00e1 acceder al Back-Office de nuestra tienda online, para ello, no podemos usar dominio/admin ya que no est\u00e1 disponible dicho directorio por tanto tenemos que acceder al volumen de Docker que hay en la instancia para saber con certeza el acceso al Back-Office. Nos conectaremos por SSH a la instancia y usaremos los comandos: sudo -s cd /var/lib/docker/volumes/docker_prestashop_data/_data ls Vemos que no hay un directorio admin , pero s\u00ed que hay un directorio administration que ser\u00e1 el que probaremos junto al dominio. Vemos que hemos podido acceder al login del Back-Office, lo siguiente es poner el email y la contrase\u00f1a que hemos asignado en el archivo docker-compose.yaml . Una vez hayamos accedido, iremos a Par\u00e1metros de la tienda ---> Configuraci\u00f3n para comprobar que tenemos realmente activado el TLS / SSL en la tienda. A continuaci\u00f3n, usaremos abriremos una nueva pesta\u00f1a y probaremos a acceder a phpMyAdmin. Tenemos que poner :point_right: dominio:8080 . Despu\u00e9s, accederemos a la base de datos que hemos designado para PrestaShop y veremos que hay bastantes tablas creadas. Por \u00faltimo, comprobaremos los logs de los contenedores, en el terminal de la instancia, saldremos de los privilegios de ROOT mediante el comando exit . Despu\u00e9s, en el directorio en el que est\u00e1n los archivo de Docker Compose, usaremos el comando: docker compose logs -f Con logs , comprobamos el funcionamiento de la infraestructura y sus \"procesos\" , con -f hacemos que se quede constantemente en primer plano, sin que muestre todos los logs que hay y luego finalice la ejecuci\u00f3n del comando. Probaremos a refrescar la tienda online y veremos que se generan nuevo contenido.","title":"PrestaShop en Docker"},{"location":"prestashop-en-docker/#prestashop-en-docker","text":"En esta pr\u00e1ctica realizaremos la misma operaci\u00f3n que en la pr\u00e1ctica anterior, salvo por el contenedor que tenemos que usar, en vez de usar WordPress, usaremos PrestaShop y adici\u00f3n de m\u00e1s variables. Puesto que de PrestaShop no hay una imagen oficial, usaremos bitnami/prestashop . Tambi\u00e9n asignaremos a la instancia al menos 8GB de memoria RAM para que PrestaShop se cree en poco tiempo. Warning Puede que las im\u00e1genes no se vean Crearemos un repositorio y lo clonaremos en nuestra m\u00e1quina local, apenas hay cambios con respecto a la pr\u00e1ctica anterior, por lo que usaremos casi todo el c\u00f3digo de la anterior pr\u00e1ctica para aprovechar el tiempo y realizar \u00fanicamente la parte del contenedor de PrestaShop. La estructura del repositorio es la siguiente: ansible inventario inventario --> Archivo playbooks delete_compose.yaml deploy_compose.yaml install_docker.yaml vars variables.yaml main.yaml docker .env docker-compose.yaml terraform main.tf variables.tf","title":"PrestaShop en Docker"},{"location":"prestashop-en-docker/#docker","text":"En esta parte tendremos lo mismo que en la anterior pr\u00e1ctica, salvo por el cambio de WordPress a PrestaShop en el archivo de docker-compose.yaml y la agregaci\u00f3n de variables al archivo .env , por lo que explicar\u00e9 las adiciones en ambos archivos.","title":"docker"},{"location":"prestashop-en-docker/#env","text":"Antes de entrar con el archivo docker-compose.yaml , asignaremos las variables que hay que usar para PrestaShop. La primera variable, USER_FIRST_NAME , nos permitir\u00e1 establecer el nombre del propietario de la tienda de PrestaShop, con la segunda variable, USER_LAST_NAME , servir\u00e1 para establecer los apellidos o el segundo nombre del propietario. Con la variable PRESTASHOP_ACCESS_EMAIL establecemos el correo electr\u00f3nico que se usar\u00e1 en PrestaShop para el acceso al Back-Office, con la variable PRESTASHOP_ACCESS_PASSWORD estableceremos la contrase\u00f1a de acceso al Back-Office. La siguiente variable, PRESTASHOP_DOMAIN , nos servir\u00e1 para indicar el nombre de dominio que tiene la tienda online, con PRESTASHOP_COUNTRY establecemos el pa\u00eds de la tienda y con PRESTASHOP_LANGUAGE establecemos el idioma para PrestaShop. USER_FIRST_NAME=\"Juan Ram\u00f3n\" USER_LAST_NAME=\"Rueda Lao\" PRESTASHOP_ACCESS_EMAIL=ujgu.ltwjr72@pihey.com PRESTASHOP_ACCESS_PASSWORD=Admin123@45 PRESTASHOP_DOMAIN=jrrlprestashop14.ddns.net PRESTASHOP_COUNTRY_LANGUAGE=es","title":".env"},{"location":"prestashop-en-docker/#docker-composeyaml","text":"Comenzaremos directamente con el contenedor de PrestaShop, usaremos la imagen bitnami/prestashop:8.0.1 , esta es la \u00faltima versi\u00f3n, por lo que por buenas pr\u00e1cticas, no usaremos latest o dejaremos en blanco la versi\u00f3n ya que al subirse otra versi\u00f3n nueva de la imagen, nos puede dar fallos al implementarla. Esta imagen realiza la instalaci\u00f3n de PrestaShop por defecto, por lo que usaremos las variables de entorno que necesitemos y queramos para personalizar el sitio web. Con la variable de entorno PRESTASHOP_FIRST_NAME asignamos el nombre del propietario que hemos declarado en el archivo de variables, con la segunda variable, PRESTASHOP_LAST_NAME estableceremos la variable para los apellidos o el segundo nombre del usuario, con la tercera variable, PRESTASHOP_EMAIL asignaremos el email que se usar\u00e1 para el acceso al Back-Office y con PRESTASHOP_PASSWORD estableceremos la contrase\u00f1a de acceso al Back-Office. En la variable PRESTASHOP_HOST , pondremos la variable para el dominio de la tienda online, en la variable PRESTASHOP_ENABLE_HTTPS=yes estableceremos que la tienda use TLS / SSL para agregar seguridad. En PRESTASHOP_COUNTRY asignaremos la variable para establecer el pa\u00eds y en PRESTASHOP_LANGUAGE usaremos la variable para indicar el idioma de la tienda. Para ir finalizando con las variables de entorno de PrestaShop, usaremos la variable PRESTASHOP_DATABASE_HOST para indicar el contenedor que tiene la base de datos, con la variable PRESTASHOP_DATABASE_NAME indicaremos la base de datos que se usar\u00e1 para crear las tablas y los registros, con PRESTASHOP_DATABASE_USER estableceremos el usuario de la base de datos y con PRESTASHOP_DATABASE_PASSWORD la contrase\u00f1a del usuario de la base de datos. A continuaci\u00f3n, si no queremos evitar perder datos, hay que usar un volumen gestionado por Docker, en este caso la variable del volumen es prestashop_data y la tenemos que vincular al directorio /bitnami/prestashop , despu\u00e9s, el contenedor esperar\u00e1 a que el contenedor mysql est\u00e9 saludable para poder ejecutarse y con un restart always para que se reinicie en cuanto tenga alg\u00fan fallo y por \u00faltimo, el contenedor estar\u00e1 conectado a las networks frontend-network y backend-network para poder servir su contenido y conectarse con el contenedor mysql. prestashop: image: bitnami/prestashop:8.0.1 # ports: # - 80:80 environment: - PRESTASHOP_FIRST_NAME=${USER_FIRST_NAME} - PRESTASHOP_LAST_NAME=${USER_LAST_NAME} - PRESTASHOP_EMAIL=${PRESTASHOP_ACCESS_EMAIL} - PRESTASHOP_PASSWORD=${PRESTASHOP_ACCESS_PASSWORD} - PRESTASHOP_HOST=${PRESTASHOP_DOMAIN} - PRESTASHOP_ENABLE_HTTPS=yes - PRESTASHOP_COUNTRY=${PRESTASHOP_COUNTRY_LANGUAGE} - PRESTASHOP_LANGUAGE=${PRESTASHOP_COUNTRY_LANGUAGE} - PRESTASHOP_DATABASE_HOST=mysql - PRESTASHOP_DATABASE_NAME=${MYSQL_DATABASE} - PRESTASHOP_DATABASE_USER=${MYSQL_USER} - PRESTASHOP_DATABASE_PASSWORD=${MYSQL_PASSWORD} volumes: - prestashop_data:/bitnami/prestashop depends_on: mysql: condition: service_healthy restart: always networks: - frontend-network - backend-network Por defecto, esta imagen de PrestaShop usa el puerto 8080 de Apache, por lo que para conectar con el contenedor prestashop, hay que indicar el contenedor con el puerto 8080. Tambi\u00e9n modificaremos el dominio de DOMAINS para que adecuarlo a la pr\u00e1ctica . https-portal: image: steveltn/https-portal ports: - '80:80' - '443:443' volumes: - ssl_certs_data:/var/lib/https-portal environment: # DOMAINS: 'localhost -> http://prestashop:8080' # STAGE: 'local' DOMAINS: 'jrrlprestashop14.ddns.net -> http://prestashop:8080' STAGE: 'production' restart: always networks: - frontend-network","title":"docker-compose.yaml"},{"location":"prestashop-en-docker/#proceso-de-trabajo","text":"Como hicimos con la pr\u00e1ctica anterior, ejecutaremos primero Terraform para montar la infraestructura en AWS y la IP el\u00e1stica que nos devuelva, la pondremos en el archivo inventario de Ansible. Despu\u00e9s ejecutaremos el archivo main.yaml con las dos primeras variables para instalar Docker, Docker Compose y pasar los archivos que hemos creado de Docker Compose, adem\u00e1s de ejecutar la infraestructura con el segundo playbook. ansible-playbook -i inventario/inventario main.yaml --extra-vars \"instalar=docker desplegar=compose\" Usaremos la IP el\u00e1stica de la instancia de AWS para asignar el dominio a la IP el\u00e1stica en No-IP . Cuando Ansible termine de ejecutar todos los playbooks que quer\u00edamos ejecutar, esperaremos un par de minutos a que la infraestructura de contenedores est\u00e9 completamente lista y accederemos al dominio que hemos preparado. Si todo ha ido bien, tendr\u00e1 que salir la tienda online montada. Lo siguiente que haremos ser\u00e1 acceder al Back-Office de nuestra tienda online, para ello, no podemos usar dominio/admin ya que no est\u00e1 disponible dicho directorio por tanto tenemos que acceder al volumen de Docker que hay en la instancia para saber con certeza el acceso al Back-Office. Nos conectaremos por SSH a la instancia y usaremos los comandos: sudo -s cd /var/lib/docker/volumes/docker_prestashop_data/_data ls Vemos que no hay un directorio admin , pero s\u00ed que hay un directorio administration que ser\u00e1 el que probaremos junto al dominio. Vemos que hemos podido acceder al login del Back-Office, lo siguiente es poner el email y la contrase\u00f1a que hemos asignado en el archivo docker-compose.yaml . Una vez hayamos accedido, iremos a Par\u00e1metros de la tienda ---> Configuraci\u00f3n para comprobar que tenemos realmente activado el TLS / SSL en la tienda. A continuaci\u00f3n, usaremos abriremos una nueva pesta\u00f1a y probaremos a acceder a phpMyAdmin. Tenemos que poner :point_right: dominio:8080 . Despu\u00e9s, accederemos a la base de datos que hemos designado para PrestaShop y veremos que hay bastantes tablas creadas. Por \u00faltimo, comprobaremos los logs de los contenedores, en el terminal de la instancia, saldremos de los privilegios de ROOT mediante el comando exit . Despu\u00e9s, en el directorio en el que est\u00e1n los archivo de Docker Compose, usaremos el comando: docker compose logs -f Con logs , comprobamos el funcionamiento de la infraestructura y sus \"procesos\" , con -f hacemos que se quede constantemente en primer plano, sin que muestre todos los logs que hay y luego finalice la ejecuci\u00f3n del comando. Probaremos a refrescar la tienda online y veremos que se generan nuevo contenido.","title":"Proceso de trabajo"},{"location":"specimen/","text":"Cinder Theme Specimen Typography \u00b6 Typefaces \u00b6 Headers: Inter Body: Open Sans Code: Hack Body Copy \u00b6 You think water moves fast? You should see ice. It moves like it has a mind . Like it knows it killed the world once and got a taste for murder. After the avalanche, it took us a week to climb out . Now, I don't know exactly when we turned on each other, but I know that seven of us survived the slide... and only five made it out. Now we took an oath, that I'm breaking now. We said we'd say it was the snow that killed the other two, but it wasn't. Nature is lethal but it doesn't hold a candle to man. Like inline code? Here is a string for you 010101010 . Lead Body Copy \u00b6 Vivamus sagittis lacus vel augue laoreet rutrum faucibus dolor auctor. Duis mollis, est non commodo luctus. Headings \u00b6 All HTML headings, <h1> through <h6> , are available. .h1 through .h6 classes are also available, for when you want to match the font styling of a heading but still want your text to be displayed inline. h1. Heading h2. Heading h3. Heading h4. Heading h5. Heading h6. Heading h1. Heading Secondary text h2. Heading Secondary text h3. Heading Secondary text h4. Heading Secondary text h5. Heading Secondary text h6. Heading Secondary text Blockquotes \u00b6 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Someone famous in Source Title Lists \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Horizontal Description Lists \u00b6 Something This is something SomethingElse This is something else Contextual Colors \u00b6 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Code \u00b6 Inline Code \u00b6 This is an example of inline code #import requests Preformatted Code Blocks with Syntax Highlighting def request(method, url, **kwargs): \"\"\"Constructs and sends a :class:`Request `. Usage:: >>> import requests >>> req = requests.request('GET', 'https://httpbin.org/get') \"\"\" # By using the 'with' statement we are sure the session is closed, thus we # avoid leaving sockets open which can trigger a ResourceWarning in some # cases, and look like a memory leak in others. with sessions.Session() as session: return session.request(method=method, url=url, **kwargs) def get(url, params=None, **kwargs): r\"\"\"Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary, list of tuples or bytes to send in the body of the :class:`Request`. :param \\*\\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response ` object :rtype: requests.Response \"\"\" kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) (Source code sample from the Python requests library , Apache License, v2.0 ) Syntax highlighting support is available for and of the following languages listed on the highlightjs website . See the mkdocs \"styling your docs\" hljs_languages section for info on how to load languages dynamically. Note Include source code formatted in Github-flavored Markdown fenced code blocks with an info string that defines the supported programming language to automate syntax highlighting when your site is built. Tables \u00b6 Striped Table \u00b6 # Head 1 Head 2 Head 3 1 Box 1 Box 2 Box 3 2 Box 4 Box 5 Box 6 3 Box 7 Box 8 Box 9 Bordered Table \u00b6 # Head 1 Head 2 Head 3 1 Box 1 Box 2 Box 3 2 Box 4 Box 5 Box 6 3 Box 7 Box 8 Box 9 Buttons \u00b6 Default Buttons \u00b6 Link Button Styled Buttons \u00b6 Default Primary Success Info Warning Danger Button Sizes \u00b6 Large button Large button Default button Default button Small button Small button Extra small button Extra small button Block Level Buttons \u00b6 Block level button Block level button Alerts \u00b6 A simple primary alert\u2014check it out! A simple secondary alert\u2014check it out! A simple success alert\u2014check it out! A simple danger alert\u2014check it out! A simple warning alert\u2014check it out! A simple info alert\u2014check it out! A simple light alert\u2014check it out! A simple dark alert\u2014check it out! Callouts \u00b6 Default Callout This is a default callout. Primary Callout This is a primary callout. Success Callout This is a success callout. Info Callout This is an info callout. Warning Callout This is a warning callout. Danger Callout This is a danger callout. Admonitions \u00b6 The following admonitions are formatted like the callouts above but can be implemented in Markdown when you include the admonition Markdown extension in your mkdocs.yml file. Add the following setting to mkdocs.yml : markdown_extensions: - admonition and then follow the instructions in the extension documentation to author admonitions in your documentation. Cinder currently supports note , warning , and danger admonition types. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. # this is a note def func(arg) { # notable things are in here! return None } Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. # this is a warning def func(arg) { # be careful! return None } Danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. # this is dangerous def func(arg) { # BOOM! return None }","title":"Specimen"},{"location":"specimen/#typography","text":"","title":"Typography"},{"location":"specimen/#typefaces","text":"Headers: Inter Body: Open Sans Code: Hack","title":"Typefaces"},{"location":"specimen/#body-copy","text":"You think water moves fast? You should see ice. It moves like it has a mind . Like it knows it killed the world once and got a taste for murder. After the avalanche, it took us a week to climb out . Now, I don't know exactly when we turned on each other, but I know that seven of us survived the slide... and only five made it out. Now we took an oath, that I'm breaking now. We said we'd say it was the snow that killed the other two, but it wasn't. Nature is lethal but it doesn't hold a candle to man. Like inline code? Here is a string for you 010101010 .","title":"Body Copy"},{"location":"specimen/#lead-body-copy","text":"Vivamus sagittis lacus vel augue laoreet rutrum faucibus dolor auctor. Duis mollis, est non commodo luctus.","title":"Lead Body Copy"},{"location":"specimen/#headings","text":"All HTML headings, <h1> through <h6> , are available. .h1 through .h6 classes are also available, for when you want to match the font styling of a heading but still want your text to be displayed inline.","title":"Headings"},{"location":"specimen/#blockquotes","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Someone famous in Source Title","title":"Blockquotes"},{"location":"specimen/#lists","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Lists"},{"location":"specimen/#horizontal-description-lists","text":"Something This is something SomethingElse This is something else","title":"Horizontal Description Lists"},{"location":"specimen/#contextual-colors","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.","title":"Contextual Colors"},{"location":"specimen/#code","text":"","title":"Code"},{"location":"specimen/#inline-code","text":"This is an example of inline code #import requests","title":"Inline Code"},{"location":"specimen/#tables","text":"","title":"Tables"},{"location":"specimen/#striped-table","text":"# Head 1 Head 2 Head 3 1 Box 1 Box 2 Box 3 2 Box 4 Box 5 Box 6 3 Box 7 Box 8 Box 9","title":"Striped Table"},{"location":"specimen/#bordered-table","text":"# Head 1 Head 2 Head 3 1 Box 1 Box 2 Box 3 2 Box 4 Box 5 Box 6 3 Box 7 Box 8 Box 9","title":"Bordered Table"},{"location":"specimen/#buttons","text":"","title":"Buttons"},{"location":"specimen/#default-buttons","text":"Link Button","title":"Default Buttons"},{"location":"specimen/#styled-buttons","text":"Default Primary Success Info Warning Danger","title":"Styled Buttons"},{"location":"specimen/#button-sizes","text":"Large button Large button Default button Default button Small button Small button Extra small button Extra small button","title":"Button Sizes"},{"location":"specimen/#block-level-buttons","text":"Block level button Block level button","title":"Block Level Buttons"},{"location":"specimen/#alerts","text":"A simple primary alert\u2014check it out! A simple secondary alert\u2014check it out! A simple success alert\u2014check it out! A simple danger alert\u2014check it out! A simple warning alert\u2014check it out! A simple info alert\u2014check it out! A simple light alert\u2014check it out! A simple dark alert\u2014check it out!","title":"Alerts"},{"location":"specimen/#callouts","text":"","title":"Callouts"},{"location":"specimen/#admonitions","text":"The following admonitions are formatted like the callouts above but can be implemented in Markdown when you include the admonition Markdown extension in your mkdocs.yml file. Add the following setting to mkdocs.yml : markdown_extensions: - admonition and then follow the instructions in the extension documentation to author admonitions in your documentation. Cinder currently supports note , warning , and danger admonition types. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. # this is a note def func(arg) { # notable things are in here! return None } Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. # this is a warning def func(arg) { # be careful! return None } Danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. # this is dangerous def func(arg) { # BOOM! return None }","title":"Admonitions"}]}